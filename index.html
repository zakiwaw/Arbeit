<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
    <title>Fracht Tracker (V8.18 - Refactored)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
<style>
    :root{--primary-color:#5cb85c;--primary-hover:#4cae4c;--secondary-color:#5bc0de;--secondary-hover:#31b0d5;--danger-color:#d9534f;--danger-hover:#c9302c;--warning-color:#f0ad4e;--warning-hover:#ec971f;--info-color:#5bc0de;--info-hover:#31b0d5;--light-bg:#f9f9f9;--border-color:#ddd;--text-color:#333;--cancelled-color:#999;}
    body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;margin:0;padding:0;background-color:#f4f4f4;color:var(--text-color);font-size:16px;-webkit-text-size-adjust:100%;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative}
    input[type="text"],input[type="number"]{-webkit-user-select:text;user-select:text}
    .container{padding:10px;max-width:100%;box-sizing:border-box}
    h1,h2{text-align:center;margin-top:15px;margin-bottom:15px} h1{font-size:1.6em} h2{font-size:1.3em}
    .input-section{margin-bottom:10px;margin-top:10px;padding:15px;border:1px solid var(--border-color);border-radius:8px;background-color:var(--light-bg);display:flex;flex-direction:column;gap:15px}
    .controls-row{display:flex;flex-wrap:wrap;gap:15px;align-items:center;padding-top:5px}
    label{display:block;margin-bottom:5px;font-weight:bold}
    input[type="text"],select,input[type="number"]{width:100%;padding:12px 10px;border:1px solid #ccc;border-radius:5px;box-sizing:border-box;font-size:1em;height:44px}
    input:disabled{background-color:#eee;cursor:not-allowed}
    .input-wrapper{position:relative}
    .clear-input-btn{position:absolute;right:8px;top:50%;transform:translateY(-50%);background:#bbb;color:white;border:none;border-radius:50%;width:24px;height:24px;font-size:16px;line-height:22px;text-align:center;cursor:pointer;display:none;padding:0}
    .clear-input-btn:hover{background:#999}
    .input-wrapper input[type="text"]{padding-right:35px}
    .combo-checkbox-group{display:none;align-items:center;padding:5px 0} .combo-checkbox-group input{width:20px;height:20px;margin-right:8px} .combo-checkbox-group label{margin-bottom:0;font-weight:normal;font-size:1em;cursor:pointer} #comboCheckboxContainer.visible{display:flex}
    .note-toggle-btn{background-color:#f0f0f0;border:1px solid #ccc;border-radius:5px;padding:5px 8px;font-size:1.2em;line-height:1;cursor:pointer;transition:background-color .2s,border-color .2s,color .2s;margin-left:auto;flex-shrink:0;height:38px;width:45px;display:flex;align-items:center;justify-content:center}
    .note-toggle-btn:hover{background-color:#e0e0e0}
    .note-toggle-btn.note-active{background-color:var(--warning-color);border-color:var(--warning-hover);color:white}
    .note-input-area{display:none;margin-top:10px;padding:10px;border:1px dashed var(--warning-color);border-radius:5px;background-color:#fffaf0}
    .note-input-area label{font-weight:bold;margin-bottom:5px;display:block}
    .note-input-area .input-wrapper{position:relative}
    .note-input-area input[type="text"]{width:100%;padding-right:35px;height:44px;box-sizing:border-box}
    .clear-note-btn{position:absolute;right:8px;top:50%;transform:translateY(-50%);background:#bbb;color:white;border:none;border-radius:50%;width:24px;height:24px;font-size:16px;line-height:22px;text-align:center;cursor:pointer;padding:0;display:block !important}
    .clear-note-btn:hover{background:#999}
    .main-action-button{background-color:var(--primary-color);color:white;padding:12px 15px;border:none;border-radius:5px;cursor:pointer;font-size:1.1em;height:48px;text-align:center;width:100%;transition:background-color .2s} .main-action-button:hover,.main-action-button:active{background-color:var(--primary-hover)}
    .delete-btn{background-color:var(--danger-color) !important}
    .delete-btn:hover,.delete-btn:active{background-color:var(--danger-hover) !important}
    #newTotalSection{display:none;flex-direction:column;gap:10px;border-top:1px solid #ccc;margin-top:15px;padding-top:15px}
    #newTotalSection.visible{display:flex}
    #newTotalSection div{display:flex;gap:10px;margin-top:10px}
    #newTotalSection button{flex-grow:1}
    #confirmNewTotalBtn{background-color:var(--primary-color)}
    #confirmNewTotalBtn:hover{background-color:var(--primary-hover)}
    #skipNewTotalBtn{background-color:var(--secondary-color)}
    #skipNewTotalBtn:hover{background-color:var(--secondary-hover)}
    .batch-controls{display:flex;justify-content:flex-end;align-items:center;margin-bottom:5px;padding:8px 10px;background-color:#e9e9e9;border-radius:5px;gap:15px;position:relative;z-index:10}
    #menu-toggle-btn{background-color:var(--secondary-color);color:white;border:none;border-radius:5px;padding:6px 10px;font-size:1.2em;line-height:1;cursor:pointer;box-shadow:0 1px 3px rgba(0,0,0,0.1);order:-1;margin-right:auto}
    #menu-toggle-btn:hover{background-color:var(--secondary-hover)}
    .batch-controls label{margin:0}
    .batch-toggle-switch{position:relative;display:inline-block;width:50px;height:28px;flex-shrink:0}
    .batch-toggle-switch input{opacity:0;width:0;height:0}
    .batch-slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background-color:#ccc;transition:.4s;border-radius:28px}
    .batch-slider:before{position:absolute;content:"";height:20px;width:20px;left:4px;bottom:4px;background-color:white;transition:.4s;border-radius:50%}
    input:checked+.batch-slider{background-color:var(--primary-color)}
    input:checked+.batch-slider:before{transform:translateX(22px)}
    .batch-status-display{font-size:.9em;color:#555;text-align:right;margin-left:5px}
    .batch-area{display:none;margin-top:15px;padding:10px;border:1px solid var(--info-color);border-radius:8px;background-color:#f0f8ff} .batch-area.visible{display:block} .batch-area h3{margin-top:0;text-align:center;color:var(--info-color);font-size:1.1em} #batchList{list-style-type:none;padding:0;margin:10px 0;max-height:150px;overflow-y:auto;border:1px solid #eee;background-color:#fff;border-radius:4px} #batchList li{display:flex;justify-content:space-between;align-items:center;padding:5px 8px;border-bottom:1px solid #eee;font-family:monospace;font-size:.95em} #batchList li:last-child{border-bottom:none} .remove-batch-item{background-color:var(--danger-color);color:white;border:none;border-radius:3px;padding:2px 5px;font-size:.8em;cursor:pointer;margin-left:10px} .batch-action-buttons{display:flex;justify-content:space-around;margin-top:10px;gap:10px} .batch-action-buttons button{flex-grow:1;padding:10px;font-size:1em;border-radius:5px;border:none;cursor:pointer;transition:background-color .2s} #saveBatchButton{background-color:var(--primary-color);color:white} #saveBatchButton:hover{background-color:var(--primary-hover)} #clearBatchButton{background-color:var(--warning-color);color:white} #clearBatchButton:hover{background-color:var(--warning-hover)}
    .error{color:var(--danger-color);font-weight:bold;margin-top:5px;min-height:1.2em;text-align:center;padding:5px}
    #currentShipmentDetails{margin-top:15px;padding:10px;background-color:#eef;border:1px dashed #aac;border-radius:8px;font-size:.9em;line-height:1.5}
    #currentShipmentDetails strong{color:#335;display:block;margin-bottom:8px}
    #currentShipmentDetails ul{margin:5px 0;padding-left:5px;list-style-type:none}
    #currentShipmentDetails li{margin-bottom:4px;padding-bottom:4px;font-family:monospace;white-space:pre-wrap;position:relative;padding-right:70px;border-bottom:1px dotted #ccc;line-height:1.3}
    #currentShipmentDetails li .timestamp{color:#557;display:block;font-size:.9em}
    #currentShipmentDetails li .status{font-weight:bold}
    #currentShipmentDetails li .combo{font-style:italic;color:#66a;margin-left:5px}
    #currentShipmentDetails li.cancelled-item{text-decoration:line-through;color:var(--cancelled-color)}
    #currentShipmentDetails li.cancelled-item .timestamp,#currentShipmentDetails li.cancelled-item .status,#currentShipmentDetails li.cancelled-item .combo,#currentShipmentDetails li.cancelled-item .note-display,#currentShipmentDetails li.cancelled-item .editable-note,#currentShipmentDetails li.cancelled-item .add-note-link{color:var(--cancelled-color) !important;cursor:default;text-decoration:none}
    #currentShipmentDetails li.cancelled-item .add-note-link{display:none}
    #currentShipmentDetails li .cancelled-info{font-size:.85em;display:block;text-decoration:none !important;color:#777}
    .cancel-button{position:absolute;right:5px;top:50%;transform:translateY(-50%);background-color:var(--warning-color);color:white;border:none;border-radius:4px;padding:3px 6px;font-size:.8em;cursor:pointer;transition:background-color .2s}
    .cancel-button:hover,.cancel-button:active{background-color:var(--warning-hover)}

    #currentShipmentDetails li .editable-note{cursor:pointer;text-decoration-style:dotted;color:#007bff;margin-left:5px;font-size:.9em;font-style:italic}
    #currentShipmentDetails li .add-note-link{cursor:pointer;color:#007bff;font-size:.9em;text-decoration:none;padding-left:10px;font-style:italic}
    #currentShipmentDetails li .editable-note:hover,#currentShipmentDetails li .add-note-link:hover{color:#0056b3;text-decoration:underline;text-decoration-style:solid}
    /* Die Regel ::before wird nicht mehr ben√∂tigt und kann gel√∂scht werden */


    #currentShipmentDetails li .note-display{display:inline;padding-left:0;margin-top:0;font-style:italic;color:#448}
    #currentShipmentDetails li .note-prefix{display:inline;font-size:.9em;color:#448;margin-top:3px;padding-left:10px;font-style:italic}
    .inline-note-editor{margin-top:5px;margin-bottom:5px;padding:8px;background-color:#fffacd;border:1px solid #f0ad4e;border-radius:4px;display:flex;flex-direction:column;gap:5px;animation:fadeIn .3s ease-in-out}
    @keyframes fadeIn{from{opacity:0;transform:translateY(-5px)}to{opacity:1;transform:translateY(0)}}
    .inline-note-editor input[type="text"]{width:100%;padding:6px 8px;border:1px solid #ccc;border-radius:3px;box-sizing:border-box;font-size:.9em;height:36px}
    .inline-note-editor-actions{display:flex;gap:8px;justify-content:flex-end}
    .inline-note-editor-actions button{padding:4px 8px;font-size:.85em;border-radius:3px;border:none;cursor:pointer;color:white}
    .inline-note-save-btn{background-color:var(--primary-color)}
    .inline-note-save-btn:hover{background-color:var(--primary-hover)}
    .inline-note-cancel-btn{background-color:#aaa}
    .inline-note-cancel-btn:hover{background-color:#888}
    .editing-note .editable-note, .editing-note .add-note-link { display: none !important; } /* Versteckt "Notiz bearbeiten/hinzuf√ºgen" Links w√§hrend Bearbeitung */
    #currentShipmentDetails .summary{margin-top:10px;border-top:1px solid #ccc;padding-top:8px;font-weight:bold} #currentShipmentDetails .summary span{display:block;margin-bottom:3px} /* --- DURCH DIESEN BLOCK ERSETZEN --- */
.summary .ok, .summary-cell .ok {color:green} 
.summary .mismatch, .summary-cell .mismatch {color:orange} 
.summary .over, .summary-cell .over {color:red;font-weight:bold}
    table{width:100%;border-collapse:collapse;margin-top:20px} thead{display:none} tr{display:block;margin-bottom:15px;border:1px solid var(--border-color);border-radius:8px;padding:12px;background-color:#fff;box-shadow:0 1px 3px rgba(0,0,0,.1)} td{display:block;text-align:right;border:none;border-bottom:1px dotted #eee;padding:8px 0;position:relative;padding-left:40%;min-height:24px;font-size:.95em} td:last-child{border-bottom:none} td::before{content:attr(data-label);position:absolute;left:0;width:38%;padding-right:10px;white-space:nowrap;text-align:left;font-weight:bold;color:#555} td.summary-cell span,td.summary-cell strong{display:block} td.actions-cell{text-align:center;padding-left:0;padding-top:10px}
    td.actions-cell button.edit-btn{background-color:#6c757d} td.actions-cell button.edit-btn:hover{background-color:#5a6268} body.batch-mode-active td.actions-cell button.edit-btn{display:none}
    td.actions-cell button{background-color:var(--secondary-color);color:white;border:none;padding:8px 10px;border-radius:5px;cursor:pointer;font-size:.9em;margin:3px;transition:background-color .2s;min-width:70px} td.actions-cell button:hover,td.actions-cell button:active{background-color:var(--secondary-hover)}
    .modal-overlay{display:none;position:fixed;z-index:100;left:0;top:0;width:100%;height:100%;overflow:auto;background-color:rgba(0,0,0,.5);justify-content:center;align-items:center}
    .modal-overlay.visible{display:flex}
    .modal-content{background-color:#fefefe;margin:auto;padding:20px;border:1px solid #888;border-radius:8px;width:90%;max-width:450px;box-shadow:0 4px 8px rgba(0,0,0,.2);position:relative}
    .modal-content h3{margin-top:0;text-align:center}
    .modal-content .form-group{margin-bottom:15px}
    .modal-content label{display:block;margin-bottom:5px;font-weight:bold}
    .modal-content input[type="number"],.modal-content input[type="text"]{font-size:1em}
    .modal-content input[readonly]{background-color:#eee;cursor:not-allowed}
    .modal-actions{display:flex;justify-content:space-between;margin-top:20px;gap:10px}
    .modal-actions button{padding:10px 15px;border-radius:5px;border:none;cursor:pointer;font-size:1em;flex-grow:1}
    #saveEditButton{background-color:var(--primary-color);color:white}
    #cancelEditButton{background-color:#aaa;color:white}
    #confirmBatchNoteButton{background-color:var(--primary-color)}
    #skipBatchNoteButton{background-color:var(--secondary-color)}
    .side-menu{position:fixed;top:0;left:0;width:280px;max-width:80%;height:100vh;background-color:#fff;box-shadow:2px 0 5px rgba(0,0,0,.2);transform:translateX(-100%);transition:transform .3s ease-in-out;z-index:1010;padding:20px;box-sizing:border-box;display:flex;flex-direction:column;overflow-y:auto}
    .side-menu.open{transform:translateX(0)}
    .side-menu h3{margin-top:0;margin-bottom:25px;text-align:center;color:var(--text-color)}
    .side-menu #sendToSheetButton{background-color:var(--info-color);width:100%;margin-top:15px}
    .side-menu #sendToSheetButton:hover{background-color:var(--info-hover)}
    .side-menu #sheetStatus{margin-top:10px;margin-bottom:15px;min-height:1.2em;font-weight:bold;text-align:center}
    .side-menu #resetDataButton{margin-top:10px;width:100%}
    .side-menu #sendSummaryEmailButton{margin-top:10px;width:100%;background-color:var(--warning-color)}
    .side-menu #sendSummaryEmailButton:hover{background-color:var(--warning-hover)}
    .menu-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.5);opacity:0;visibility:hidden;transition:opacity .3s ease-in-out,visibility .3s ease-in-out;z-index:1000}
    .menu-overlay.visible{opacity:1;visibility:visible}
    .status-and-button-container {
    display: flex;
    align-items: flex-end; /* Richtet Select und Button an ihrer Unterkante aus */
    gap: 15px; /* Konsistenter Abstand, wie in .input-section */
}

.status-select-wrapper {
    flex-grow: 1; /* Erlaubt dem Select-Wrapper (mit Label), den verf√ºgbaren Platz einzunehmen */
}

/* √úberschreibt die Breite f√ºr mainActionButton, wenn er im neuen Container ist */
/* --- START DER √ÑNDERUNG --- */

/* √úberschreibt die Breite und H√∂he f√ºr mainActionButton, wenn er im neuen Container ist */
.status-and-button-container > #mainActionButton {
    width: auto; /* Beh√§lt die automatische Breitenanpassung bei */
    flex-shrink: 0; /* Verhindert, dass der Button schrumpft */
    height: 44px; /* Angleichen an die H√∂he des Select-Feldes (war 48px) */
    padding-top: 10px; /* Vertikales Padding anpassen (war 12px) */
    padding-bottom: 10px; /* Vertikales Padding anpassen (war 12px) */
    /* padding-left und padding-right (15px) bleiben unver√§ndert von .main-action-button */
    line-height: normal; /* Stellt sicher, dass line-height die Zentrierung nicht st√∂rt, falls es woanders gesetzt wurde */
    /* Die Schriftgr√∂√üe (font-size: 1.1em) wird von .main-action-button geerbt */
}
    /* --- START: NEUE STILE F√úR MEHRERE NOTIZEN --- */
    #currentShipmentDetails .notes-container {
        margin-top: 5px;
        padding-left: 15px; /* Einr√ºckung f√ºr den gesamten Notiz-Block */
        display: flex;
        flex-direction: column;
        gap: 3px;
    }
    #currentShipmentDetails .note-item {
        display: flex;
        align-items: center;
        gap: 8px; /* Abstand zwischen Notiztext und L√∂schen-Button */
    }
#currentShipmentDetails .note-item .note-prefix {
    font-weight: bold;
    color: #555;
    margin-right: 4px; /* Kleiner Abstand zum Notiztext */
}
    #currentShipmentDetails .note-item .editable-note {
        flex-grow: 1; /* Notiztext nimmt verf√ºgbaren Platz ein */
    }
    #currentShipmentDetails .note-item .delete-note-btn {
        background-color: #e7e7e7;
        color: #888;
        border: 1px solid #ccc;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        font-size: 12px;
        line-height: 18px;
        text-align: center;
        cursor: pointer;
        padding: 0;
        flex-shrink: 0;
        transition: all 0.2s;
    }
    #currentShipmentDetails .note-item .delete-note-btn:hover {
        background-color: var(--danger-color);
        color: white;
        border-color: var(--danger-hover);
    }
    /* --- ENDE: NEUE STILE F√úR MEHRERE NOTIZEN --- */
/* --- ENDE DER √ÑNDERUNG --- */
#newTotalSection.warning-existing {
    background-color: #f2dede; /* Heller Rotton */
    border-color: #ebccd1;
    border-style: solid;
    border-width: 1px;
}
#newTotalSection.warning-existing label {
    color: #a94442; /* Dunkelroter Text */
    font-weight: bold;
}


    #pendingHuList.partial {
        border-color: orange; /* Orange f√ºr "teilweise bearbeitet" */
    }
    #pendingHuList h4 {
        margin-top: 0;
        margin-bottom: 8px;
        font-size: 1em;
        color: #333;
    }
    #pendingHuList ul {
        list-style-type: none;
        padding: 0;
        margin: 0;
        max-height: 120px; /* Limitiert die H√∂he und macht die Liste scrollbar */
        overflow-y: auto;
        font-family: monospace;
        font-size: 0.95em;
    }
    #pendingHuList li {
        padding: 2px 4px;
        border-bottom: 1px dotted #ccc;
    }
    #pendingHuList li:last-child {
        border-bottom: none;
    }
    /* --- ENDE: NEUE STILE F√úR OFFENE HU-LISTE --- */
/* IN DER DATEI DSV_LFS.html, INNERHALB DES <style>-TAGS */

/* --- START: NEUE STILE F√úR OFFENE HU-ZUSAMMENFASSUNG --- */
#openHusListContainer .hu-order-group {
    margin-bottom: 15px;
    border-left: 3px solid var(--info-color);
    padding-left: 10px;
}
#openHusListContainer .hu-order-title {
    font-size: 1.1em;
    font-weight: bold;
    color: var(--text-color);
    border-bottom: 1px solid #eee;
    padding-bottom: 5px;
    margin-bottom: 8px;
}
#openHusListContainer .hu-list {
    list-style-type: none;
    padding-left: 5px;
    font-family: monospace;
}
#openHusListContainer .hu-list li {
    padding: 3px 0;
}
#openHusListContainer .no-open-hus-message {
    text-align: center;
    padding: 20px 0;
    font-style: italic;
    color: #555;
}
/* --- ENDE: NEUE STILE --- */
/* IN DER DATEI DSV_LFS.html, INNERHALB DES <style>-TAGS */

/* --- START: NEUES DESIGN F√úR SEITENMEN√ú --- */
.side-menu .side-menu-list {
    list-style: none;
    padding: 0;
    margin: 0 0 15px 0; /* Abstand nach unten zur Statusmeldung */
    display: flex;
    flex-direction: column;
    gap: 8px; /* Abstand zwischen den Men√ºpunkten */
}

.side-menu .menu-action-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-radius: 8px;
    text-decoration: none;
    font-weight: 500; /* Etwas dickere Schrift */
    color: #333;
    background-color: transparent;
    border: 1px solid transparent; /* Platzhalter f√ºr den Hover-Effekt */
    transition: all 0.2s ease-in-out;
    cursor: pointer;
}

.side-menu .menu-action-item:hover {
    background-color: #f4f4f4;
    border-color: #e0e0e0;
}

/* Stil f√ºr die Icons */
.side-menu .menu-action-item svg {
    width: 22px;
    height: 22px;
    margin-right: 15px;
    flex-shrink: 0; /* Verhindert, dass das Icon schrumpft */
    fill: currentColor; /* Icon nimmt die Textfarbe an */
}

/* Spezielle Hover-Effekte f√ºr bestimmte Aktionen */

/* Prim√§re Aktion: Senden */
.side-menu .menu-action-item.action-primary:hover {
    background-color: #eef8ff;
    color: var(--secondary-hover);
    border-color: var(--secondary-color);
}

/* Wichtige Aktion: Zusammenfassung, Import */
.side-menu .menu-action-item.action-warning:hover {
    background-color: #fffaf0;
    color: var(--warning-hover);
    border-color: var(--warning-color);
}

/* Destruktive Aktion: Zur√ºcksetzen */
.side-menu .menu-action-item.action-reset {
    /* Kein spezieller Grundzustand, nur der Hover ist anders */
}
.side-menu .menu-action-item.action-reset:hover {
    background-color: #fdeeee; /* Heller Rotton (Tippfehler korrigiert) */
    color: var(--danger-color);
    border-color: var(--danger-hover);
}

/* Die alten Button-Stile im Men√º werden nicht mehr gebraucht */
.side-menu .main-action-button {
    display: none; /* Versteckt die alten Buttons, falls sie noch da sind */
}

/* Besserer Stil f√ºr die Statusmeldung */
.side-menu #sheetStatus {
    margin-top: 10px;
    padding: 10px;
    border-radius: 5px;
    background-color: #f8f9fa;
    min-height: 1.2em;
    font-weight: bold;
    text-align: center;
    border: 1px solid #eee;
}
/* --- ENDE: NEUES DESIGN F√úR SEITENMEN√ú --- */
/* --- START: NEUE STILE F√úR MODAL-TABS --- */
.modal-tabs {
    display: flex;
    margin-bottom: 15px;
    border-bottom: 2px solid #eee;
    
    /* NEU: Horizontales Scrollen aktivieren, wenn der Inhalt √ºberl√§uft */
    overflow-x: auto;
    /* NEU: Verhindert, dass die Buttons in die n√§chste Zeile umbrechen */
    flex-wrap: nowrap;

    /* Optional: Verbessert das Scroll-Gef√ºhl auf iOS */
    -webkit-overflow-scrolling: touch;

    /* Optional: Gestaltet die Scrollleiste unauff√§lliger */
    scrollbar-width: thin;
    scrollbar-color: #ccc transparent;
}
.modal-tab-btn {
    /* √ÑNDERUNG: 'flex: 1;' wird entfernt, damit die Buttons nicht mehr gezwungen werden, den Platz auszuf√ºllen */
    
    padding: 10px 15px; /* Etwas mehr seitliches Padding f√ºr besseres Aussehen */
    font-size: 0.95em;
    font-weight: 500;
    text-align: center;
    border: none;
    background-color: transparent;
    color: #555;
    cursor: pointer;
    border-bottom: 3px solid transparent;
    transition: all 0.2s ease-in-out;

    /* NEU: Verhindert, dass die Buttons schrumpfen */
    flex-shrink: 0;
    /* NEU: Stellt sicher, dass der Text im Button nicht umbricht */
    white-space: nowrap;
}
.modal-tabs::-webkit-scrollbar {
    height: 4px; /* H√∂he der Scrollleiste */
}
.modal-tabs::-webkit-scrollbar-thumb {
    background-color: #ccc; /* Farbe des Scroll-Balkens */
    border-radius: 4px;
}
modal-tabs::-webkit-scrollbar-track
.modal-tab-btn:hover {
    background-color: #f9f9f9;
    color: var(--primary-color);
}
.modal-tab-btn.active {
    color: var(--primary-color);
    font-weight: bold;
    border-bottom-color: var(--primary-color);
}
/* --- ENDE: NEUE STILE F√úR MODAL-TABS --- */
/* --- START: NEUE STILE F√úR VOLLBILD-MODAL --- */

/* Diese Klasse wird per JavaScript zum <body> hinzugef√ºgt, wenn ein Modal offen ist */
body.modal-open {
    overflow: hidden; /* Verhindert das Scrollen des Hintergrunds */
}

/* Passt das Aussehen des Modal-Inhalts an, um den Bildschirm auszuf√ºllen */
.modal-content {
    width: 100%;
    height: 100%;
    max-width: 100%; /* √úberschreibt die alte Breitenbegrenzung */
    margin: 0;
    border: none;
    border-radius: 0; /* Entfernt abgerundete Ecken f√ºr den Vollbild-Look */
    box-shadow: none;
    
    /* Flexbox-Layout, um Header, Inhalt und Footer besser zu steuern */
    display: flex;
    flex-direction: column;
    padding: 15px; /* Etwas Padding f√ºr den Inhalt */
    box-sizing: border-box;
}

/* Sorgt daf√ºr, dass der scrollbare Bereich im Modal den verf√ºgbaren Platz einnimmt */
#openHusListContainer, 
#missingReceiptHusListContainer,
#editModal .form-group,
#importHuModal .form-group:nth-of-type(2) /* Zielt auf den Container der Textarea */ {
    flex-grow: 1; /* Dieser Bereich dehnt sich aus */
    overflow-y: auto; /* Nur dieser Bereich wird scrollbar, nicht das ganze Modal */
    min-height: 0; /* Wichtiger Fix f√ºr Flexbox-Scrolling */
}

/* Stellt sicher, dass die Textarea im Import-Modal den ganzen Platz ausf√ºllt */
#huListTextarea {
    flex-grow: 1;
    height: 100%;
}

/* Die Aktions-Buttons am Ende sollen nicht mitwachsen */
.modal-actions {
    flex-shrink: 0;
    margin-top: 15px;
}
/* --- ENDE: NEUE STILE F√úR VOLLBILD-MODAL --- */
/* --- NEU: Styling f√ºr perfekt ausgerichtete Listen im Modal --- */
#openHusListContainer .hu-list li,
#missingReceiptHusListContainer .hu-list li,
#dunkelalarmHusListContainer .hu-list li {
    display: flex;
    align-items: flex-start; /* Stellt sicher, dass die Zeilen oben beginnen */
    padding: 3px 0; /* Etwas mehr vertikaler Abstand */
}

/* --- Styling f√ºr perfekt ausgerichtete Listen --- */
/* Gilt f√ºr Modal UND Detailansicht */
#openHusListContainer .hu-list li,
#missingReceiptHusListContainer .hu-list li,
#dunkelalarmHusListContainer .hu-list li,
#pendingHuList .hu-list li {
    display: flex;
    align-items: flex-start;
    padding: 3px 0;
}

/* Basis-Styling f√ºr die Positionsnummer */
#openHusListContainer .hu-list .position-number,
#missingReceiptHusListContainer .hu-list .position-number,
#dunkelalarmHusListContainer .hu-list .position-number,
#pendingHuList .hu-list .position-number {
    min-width: 2.5em;
    text-align: right;
    padding-right: 0.75em; /* Standard-Abstand */
    flex-shrink: 0;
    color: #888;
}

/* --- HIER IST DIE SPEZIFISCHE √úBERSCHREIBUNG --- */
/* Diese Regel erh√∂ht den Abstand NUR f√ºr die pendingHuList in der Detailansicht */
#pendingHuList .hu-list .position-number {
    padding-right: 1.5em; /* Gr√∂√üerer Abstand */
}
.batch-sound-toggle-container {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 10px;
    margin-top: 15px; /* Etwas Abstand nach oben */
    font-size: 0.9em;
}
.batch-sound-toggle-container label {
    margin-bottom: 0;
    font-weight: normal;
    cursor: pointer;
}
/* --- NEU: Layout f√ºr zweizeilige Scan-Eintr√§ge --- */
#currentShipmentDetails li {
    display: flex;
    flex-wrap: wrap; /* Erlaubt den Zeilenumbruch */
    align-items: center;
    position: relative;
    padding-right: 70px; /* Platz f√ºr den Storno-Button */
}

#currentShipmentDetails .scan-main-info {
    flex-grow: 1; /* Nimmt den verf√ºgbaren Platz in der ersten Zeile ein */
    white-space: nowrap; /* Verhindert Zeilenumbruch innerhalb dieser Zeile */
    overflow: hidden;
    text-overflow: ellipsis; /* ... falls es doch zu lang wird */
}

#currentShipmentDetails .scan-actions-and-notes {
    flex-basis: 100%; /* Erzwingt, dass dieser Block immer eine neue Zeile beginnt */
    padding-left: 1.5em; /* Kleine Einr√ºckung f√ºr die Notizen */
    padding-top: 4px; /* Etwas Abstand nach oben */
}
/* INNERHALB des <style> Tags */

.hu-value.has-dunkelalarm {
    color: red;
    font-weight: bold;
}
</style>
</head>
<body>







<div id="side-menu" class="side-menu">
    <h3>Optionen</h3>

    <ul class="side-menu-list">
        <li>
            <a href="#" id="importHuListButton" class="menu-action-item action-warning">
                <svg viewBox="0 0 24 24"><path d="M9,16V10H5L12,3L19,10H15V16H9M5,20V18H19V20H5Z" /></svg>
                <span>HU-Liste importieren</span>
            </a>
        </li>
        <li>
            <a href="#" id="showOpenHusButton" class="menu-action-item">
                <svg viewBox="0 0 24 24"><path d="M12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9M12,17A5,5 0 0,1 7,12A5,5 0 0,1 12,7A5,5 0 0,1 17,12A5,5 0 0,1 12,17M12,4.5C7,4.5 2.73,7.61 1,12C2.73,16.39 7,19.5 12,19.5C17,19.5 21.27,16.39 23,12C21.27,7.61 17,4.5 12,4.5Z" /></svg>
                <span>Offene HUs anzeigen</span>
            </a>
        </li>
        <li>
            <a href="#" id="sendToSheetButton" class="menu-action-item action-primary">
                <svg viewBox="0 0 24 24"><path d="M17,13L12,18L7,13H10V9H14V13M19.35,10.03C18.67,6.59 15.64,4 12,4C9.11,4 6.6,5.64 5.35,8.03C2.34,8.36 0,10.9 0,14A6,6 0 0,0 6,20H19A5,5 0 0,0 24,15C24,12.36 21.95,10.22 19.35,10.03Z" /></svg>
                <span>An Google Sheet Senden</span>
            </a>
        </li>
        <li>
            <a href="#" id="sendSummaryEmailButton" class="menu-action-item action-warning">
                <svg viewBox="0 0 24 24"><path d="M20,8L12,13L4,8V6L12,11L20,6M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C22,4.89 21.1,4 20,4Z" /></svg>
                <span>Zusammenfassung per E-Mail</span>
            </a>
        </li>
        <li>
            <a href="#" id="resetDataButton" class="menu-action-item action-reset">
                <svg viewBox="0 0 24 24"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z" /></svg>
                <span>Alles Zur√ºcksetzen</span>
            </a>
        </li>
    </ul>

    <div id="sheetStatus"></div>
</div>
<div id="menu-overlay" class="menu-overlay"></div>
<!-- --- START DER √ÑNDERUNG --- -->
<div id="openHusModal" class="modal-overlay">
    <div class="modal-content">

        
        <!-- TAB-BUTTONS AKTUALISIERT -->
        <div class="modal-tabs">
            <button id="showOpenSecurityHusBtn" class="modal-tab-btn active">Offene Sicherung</button>
            <button id="showMissingReceiptHusBtn" class="modal-tab-btn">Fehlende Eing√§nge</button>
            <button id="showDunkelalarmHusBtn" class="modal-tab-btn">Dunkelalarm</button>
        </div>

        <!-- Container f√ºr die erste Ansicht (bestehend) -->
        <div id="openHusListContainer" style="max-height: 60vh; overflow-y: auto; padding-right: 10px;">
            <!-- Inhalt f√ºr offene Sicherung wird hier generiert -->
        </div>
        
        <!-- Container f√ºr die zweite Ansicht (bestehend) -->
        <div id="missingReceiptHusListContainer" style="max-height: 60vh; overflow-y: auto; padding-right: 10px; display: none;">
            <!-- Inhalt f√ºr fehlenden Wareneingang wird hier generiert -->
        </div>

        <!-- NEUER Container f√ºr die Dunkelalarm-Ansicht -->
        <div id="dunkelalarmHusListContainer" style="max-height: 60vh; overflow-y: auto; padding-right: 10px; display: none;">
            <!-- Inhalt f√ºr Dunkelalarm-Sendungen wird hier generiert -->
        </div>

        <div class="modal-actions" style="justify-content: center; margin-top: 20px;">
            <button id="closeOpenHusModalButton" class="main-action-button" style="width: 50%;">Schlie√üen</button>
        </div>
    </div>
</div>
<!-- --- ENDE DER √ÑNDERUNG --- -->
<div class="container">
    <div class="batch-controls">
        <button id="menu-toggle-btn" title="Men√º √∂ffnen/schlie√üen">‚ò∞</button>
        <label for="batchModeToggle">Batch-Modus:</label>
        <label class="batch-toggle-switch">
            <input type="checkbox" id="batchModeToggle">
            <span class="batch-slider"></span>
        </label>
        <span id="batchStatusDisplay"></span>
    </div>

    <div class="input-section">
        <div>
            <label for="shipmentNumberInput">HAWB/HU:</label>
            <div class="input-wrapper">
                <input type="text" id="shipmentNumberInput" placeholder="Scannen oder eingeben..." autocapitalize="characters" autocomplete="off">
                <button type="button" id="clearInputButton" class="clear-input-btn" title="Eingabe l√∂schen">√ó</button>
            </div>
        </div>
    
        <div class="status-and-button-container"> <!-- Container f√ºr Status und Button nebeneinander -->
            <div class="status-select-wrapper"> <!-- Wrapper f√ºr Label und Select -->
                <label for="securityStatusSelect">Status:</label>
                <select id="securityStatusSelect">
                    <option value="XRY">XRY</option><option value="ETD">ETD</option><option value="EDD">EDD</option>
			<option value="Wareneingang">Wareneingang</option> <!-- NEUE ZEILE -->
                    <option value="Dunkelalarm">Dunkelalarm</option><option value="Anstehend">Anstehend</option>
                    <option value="NichtSichern">Nicht Erf.</option><option value="Abgelehnt">Abgelehnt</option>
                </select>
            </div>
            <button id="mainActionButton" class="main-action-button">Hinzuf√ºgen</button>
        </div>
    
        <div class="controls-row" id="controlsRow">
            <div class="combo-checkbox-group" id="comboCheckboxContainer">
                 <input type="checkbox" id="comboCheckbox"><label for="comboCheckbox" id="comboCheckboxLabel">Kombi-Sicherung</label>
            </div>
            <button type="button" id="noteToggleButton" class="note-toggle-btn" title="Notiz hinzuf√ºgen/bearbeiten (Einzelscan)">üìù</button>
        </div>
    
        <div id="noteInputContainer" class="note-input-area">
            <label for="noteInput">Notiz (f√ºr n√§chsten Einzelscan):</label>
            <div class="input-wrapper">
                <input type="text" id="noteInput" placeholder="Notiz eingeben..." list="noteSuggestions">
                <button type="button" id="clearNoteButton" class="clear-input-btn clear-note-btn" title="Notiz l√∂schen">√ó</button>
                <datalist id="noteSuggestions">
                    <option value="Abgepackt"><option value="Muss abgepackt werden"><option value="Eingeschwei√üte Folien">
                    <option value="Aluverbundfolie"><option value="Fl√ºssigkeit"><option value="F√§sser">
                    <option value="Verklebte Kartons"><option value="Vakuumfolie"><option value="Kanister">
                    <option value="Eimer"><option value="S√§cke"><option value="Wird gesucht!">
                </datalist>
            </div>
        </div>
    
        <div id="newTotalSection">
            <label for="newTotalInput" id="newTotalLabel">Erwartete Gesamtst√ºckzahl f√ºr NEUE Sendung:</label>
            <input type="number" id="newTotalInput" inputmode="numeric" placeholder="Zahl eingeben...">
            <div>
                <button id="confirmNewTotalBtn" class="main-action-button">OK</button>
                <button id="skipNewTotalBtn" class="main-action-button">√úberspringen (N/A)</button>
            </div>
        </div>
        <!-- Der Button #mainActionButton war urspr√ºnglich hier und wurde nach oben verschoben -->
    </div>

    <div id="errorDisplay" class="error"></div>


<div class="batch-area" id="batchArea">
    <h3>Aktueller Batch (<span id="batchModeStatusLabel"></span>)</h3>
    <div id="currentBatchNoteDisplay" style="font-style:italic;margin-bottom:5px;font-size:.9em"></div>
    <ul id="batchList"></ul>
    <div id="batchSummary">Anzahl im Batch: <span id="batchItemCount">0</span></div>
    
    <div class="batch-note-toggle-container" style="display: flex; justify-content: flex-end; align-items: center; gap: 10px; margin-top: 10px; font-size: 0.9em;">
        <label for="batchNoteToggle" style="margin-bottom: 0; font-weight: normal;">Notiz-Popup aktivieren:</label>
        <label class="batch-toggle-switch">
            <input type="checkbox" id="batchNoteToggle">
            <span class="batch-slider"></span>
        </label>
    </div>

    <!-- HIER IST DER NEUE SWITCH F√úR DEN √úBERZ√ÑHLIG-TON -->
    <div class="batch-sound-toggle-container">
        <label for="unexpectedHuSoundToggle" title="Ton abspielen, wenn eine HU auf keiner Liste steht">üîä √úberz√§hlig-Ton</label>
        <label class="batch-toggle-switch">
            <input type="checkbox" id="unexpectedHuSoundToggle" checked>
            <span class="batch-slider"></span>
        </label>
    </div>
    <!-- ENDE DES NEUEN SWITCHES -->

    <div class="batch-action-buttons">
        <button id="saveBatchButton">Batch Speichern</button>
        <button id="clearBatchButton">Batch Leeren</button>
    </div>
</div>

    <div id="currentShipmentDetails">Geben Sie eine Sendungsnummer ein...</div>


<div id="importHuModal" class="modal-overlay">
    <div class="modal-content">
        <h3>HU-Liste Importieren</h3>
        <div class="form-group">
            <label for="mainOrderNumberInput">Auftragsnummer (z.B. 9007769889):</label>
            <!-- HIER die √Ñnderung -->
            <div style="display: flex; align-items: center; gap: 10px;">
                <input type="text" id="mainOrderNumberInput" placeholder="√úbergeordnete Auftragsnummer eingeben" inputmode="none" style="flex-grow: 1;">
                <button type="button" id="addAndContinueHuButton" title="Speichern und n√§chste Liste eingeben" class="main-action-button" style="width: 44px; height: 44px; padding: 0; font-size: 2em; flex-shrink: 0; line-height: 44px;">+</button>
            </div>
        </div>
        <div class="form-group">
            <label for="huListTextarea">HU Nummern (eine pro Zeile):</label>
            <!-- UND HIER die √Ñnderung -->
            <textarea id="huListTextarea" rows="8" style="width: 100%; font-family: monospace; font-size: 1em; padding: 8px; border: 1px solid #ccc; border-radius: 5px; box-sizing: border-box;" placeholder="HU Nummern hier einf√ºgen..." inputmode="none"></textarea>
        </div>
        <div class="modal-actions">
            <button id="saveHuListButton">Importieren & Speichern</button>
            <button id="cancelHuImportButton">Abbrechen</button>
        </div>
    </div>
</div>
<!-- ENDE: NEUE ELEMENTE F√úR HU-LISTEN-IMPORT -->
    <h2>Erfasste Sendungen</h2>
    <table>
        <thead>
            <tr><th>HAWB.</th><th>√úbersicht</th><th>Letzte √Ñnd.</th><th>Aktionen</th></tr>
        </thead>
        <tbody id="shipmentTableBody"></tbody>
    </table>

    <div id="editModal" class="modal-overlay">
        <div class="modal-content">
            <h3>Sendung Bearbeiten</h3>
            <input type="hidden" id="editShipmentBaseNumber">
            <div class="form-group">
                <label for="editShipmentNumberDisplay">Sendungsnummer:</label>
                <input type="text" id="editShipmentNumberDisplay" readonly>
            </div>
 <div class="form-group">
                <label for="editGoodsReceiptCount">Manuelle Anzahl Wareneingang:</label>
                <input type="number" id="editGoodsReceiptCount" inputmode="numeric" placeholder="Leer lassen, um Scans zu nutzen">
            </div>
            <div class="form-group">
                <label for="editTotalPiecesExpected">Erwartete Gesamtst√ºckzahl:</label>
                <input type="number" id="editTotalPiecesExpected" inputmode="numeric" placeholder="Zahl oder leer">
            </div>
            <div class="modal-actions">
                <button id="saveEditButton">Speichern</button>
                <button id="cancelEditButton">Abbrechen</button>
            </div>
        </div>
    </div>

    <div id="batchNoteModal" class="modal-overlay">
        <div class="modal-content">
            <h3>Batch-Notiz Festlegen</h3>
            <div class="form-group">
                <label for="batchNoteInput">Notiz f√ºr alle Scans in diesem Batch (optional):</label>
                <input type="text" id="batchNoteInput" placeholder="Notiz eingeben..." list="noteSuggestions">
            </div>
            <div class="modal-actions">
                <button id="confirmBatchNoteButton" class="main-action-button">√úbernehmen & Scannen</button>
                <button id="skipBatchNoteButton" class="main-action-button" style="background-color:var(--secondary-color)">Ohne Notiz Scannen</button>
            </div>
        </div>
    </div>
</div>

<script>
    const { jsPDF } = window.jspdf;

    document.addEventListener('DOMContentLoaded', function() {
        // --- DOM Elemente ---
        const shipmentNumberInputEl = document.getElementById('shipmentNumberInput');
        const editGoodsReceiptCountInputEl = document.getElementById('editGoodsReceiptCount');
        const clearInputButtonEl = document.getElementById('clearInputButton');
        const securityStatusSelectEl = document.getElementById('securityStatusSelect');
        const comboCheckboxEl = document.getElementById('comboCheckbox');
        const comboCheckboxContainerEl = document.getElementById('comboCheckboxContainer');
        const mainActionButtonEl = document.getElementById('mainActionButton');
        const tableBodyEl = document.getElementById('shipmentTableBody');
        const currentDetailsDivEl = document.getElementById('currentShipmentDetails');
        const errorDisplayEl = document.getElementById('errorDisplay');
        const batchModeToggleEl = document.getElementById('batchModeToggle');
        const batchStatusDisplayEl = document.getElementById('batchStatusDisplay');
        const batchAreaEl = document.getElementById('batchArea');
        const batchModeStatusLabelEl = document.getElementById('batchModeStatusLabel');
        const batchListEl = document.getElementById('batchList');
        const batchItemCountEl = document.getElementById('batchItemCount');
        const saveBatchButtonEl = document.getElementById('saveBatchButton');
        const clearBatchButtonEl = document.getElementById('clearBatchButton');
        const editModalEl = document.getElementById('editModal');
        const editShipmentBaseNumberInputEl = document.getElementById('editShipmentBaseNumber');
        const editShipmentNumberDisplayEl = document.getElementById('editShipmentNumberDisplay');
        const editTotalPiecesExpectedInputEl = document.getElementById('editTotalPiecesExpected');
        const saveEditButtonEl = document.getElementById('saveEditButton');
        const cancelEditButtonEl = document.getElementById('cancelEditButton');
        const newTotalSectionEl = document.getElementById('newTotalSection');
        const newTotalLabelEl = document.getElementById('newTotalLabel');
        const newTotalInputEl = document.getElementById('newTotalInput');
        const confirmNewTotalBtnEl = document.getElementById('confirmNewTotalBtn');
        const skipNewTotalBtnEl = document.getElementById('skipNewTotalBtn');
        const sendToSheetButtonEl = document.getElementById('sendToSheetButton');
        const sheetStatusEl = document.getElementById('sheetStatus');
        const menuToggleBtnEl = document.getElementById('menu-toggle-btn');
        const sideMenuEl = document.getElementById('side-menu');
        const menuOverlayEl = document.getElementById('menu-overlay');
        const resetDataButtonEl = document.getElementById('resetDataButton');
        const sendSummaryEmailButtonEl = document.getElementById('sendSummaryEmailButton');
        const noteToggleButtonEl = document.getElementById('noteToggleButton');
        const noteInputContainerEl = document.getElementById('noteInputContainer');
        const noteInputEl = document.getElementById('noteInput');
        const clearNoteButtonEl = document.getElementById('clearNoteButton');
        const batchNoteModalEl = document.getElementById('batchNoteModal');
        const batchNoteInputEl = document.getElementById('batchNoteInput');
        const confirmBatchNoteButtonEl = document.getElementById('confirmBatchNoteButton');
        const skipBatchNoteButtonEl = document.getElementById('skipBatchNoteButton');
const batchNoteToggleEl = document.getElementById('batchNoteToggle'); // <-- DIESE ZEILE HINZUF√úGEN
        const currentBatchNoteDisplayEl = document.getElementById('currentBatchNoteDisplay');
	 const containerEl = document.querySelector('.container'); // <-- DIESE ZEILE HINZUF√úGEN
        const importHuListButtonEl = document.getElementById('importHuListButton');
        const importHuModalEl = document.getElementById('importHuModal');
        const mainOrderNumberInputEl = document.getElementById('mainOrderNumberInput');
        const huListTextareaEl = document.getElementById('huListTextarea');
        const saveHuListButtonEl = document.getElementById('saveHuListButton');
        const cancelHuImportButtonEl = document.getElementById('cancelHuImportButton');
	const addAndContinueHuButtonEl = document.getElementById('addAndContinueHuButton');
	const showOpenHusButtonEl = document.getElementById('showOpenHusButton');
const openHusModalEl = document.getElementById('openHusModal');
const openHusListContainerEl = document.getElementById('openHusListContainer');
const closeOpenHusModalButtonEl = document.getElementById('closeOpenHusModalButton');
// In der N√§he der anderen Modal-Variablen einf√ºgen
const showOpenSecurityHusBtnEl = document.getElementById('showOpenSecurityHusBtn');
const showMissingReceiptHusBtnEl = document.getElementById('showMissingReceiptHusBtn');
const missingReceiptHusListContainerEl = document.getElementById('missingReceiptHusListContainer');
const showDunkelalarmHusBtnEl = document.getElementById('showDunkelalarmHusBtn');
const dunkelalarmHusListContainerEl = document.getElementById('dunkelalarmHusListContainer');
const errorSoundEl = document.getElementById('errorSound');
const unexpectedHuSoundToggleEl = document.getElementById('unexpectedHuSoundToggle');

        // --- Konstanten & Konfiguration ---

        const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbweFC3K1wgksWq3Dd79bJDkbsBdYaORycXSlbIGvQ5JDe6eYj7PtTti3gpBJArRSdp63Q/exec';
        const LOCAL_STORAGE_KEY = 'frachtSicherungMobile_V8_18_Refactored';
        const SUFFIX_LENGTH = 4;
        const MITARBEITER_NAME = "Zakaria Bisbiss";
        const RAC_NUMMER = "DE/RA/00151-20";
        const NON_COUNTING_STATUSES = ['Dunkelalarm', 'Anstehend', 'NichtSichern', 'Abgelehnt', 'Wareneingang']; // <-- WARENEINGANG HINZUGEF√úGT
        const NOTE_ALLOWED_STATUSES = ['XRY', 'Abgelehnt', 'Dunkelalarm', 'ETD', 'EDD'];
	        // In der N√§he von const NON_COUNTING_STATUSES = ... einf√ºgen
        const EXCLUSIVE_SECURITY_STATUSES = ['XRY', 'ETD', 'EDD']; // Status, die nur einmal vergeben werden d√ºrfen

        // --- Anwendungsstatus ---
        let isBatchModeActive = false;
        let currentBatch = [];
        let batchStatus = '';
        let batchIsCombination = false;
        let pendingScanDataForNewShipment = null;
let pendingTotalUpdateInfo = null; 
        let sessionFirstSuffixScans = {}; // Trackt erste Suffix-Scans pro HAWB in der Session
        let notifiedCompletions = new Set(); // Trackt HAWBs, f√ºr die schon eine Abschlussmail gesendet wurde
        let currentBatchGlobalNote = null;
        let isBatchNotePromptRequired = true;
        let pendingFirstBatchScanData = null;

        // --- Hilfsfunktionen: Persistenz ---
   function loadShipments() {
            const data = localStorage.getItem(LOCAL_STORAGE_KEY);
            const shipments = data ? JSON.parse(data) : {};

            // Datenmigration: Konvertiert alte 'note' (string) zu neuer 'notes' (array)
            Object.values(shipments).forEach(shipment => {
                if (shipment.scannedItems && Array.isArray(shipment.scannedItems)) {
                    shipment.scannedItems.forEach(item => {
                        if (item.hasOwnProperty('note') && !item.hasOwnProperty('notes')) {
                            item.notes = item.note ? [item.note] : [];
                            delete item.note;
                        } else if (!item.hasOwnProperty('notes')) {
                            item.notes = [];
                        }
                    });
                }
            });
            return shipments;
        }
// In der N√§he von calculateCurrentCountedPieces einf√ºgen

function calculateGoodsReceiptCount(scannedItems) {
    if (!Array.isArray(scannedItems)) return 0;
    // Z√§hlt nur Scans mit dem Status "Wareneingang", die nicht storniert sind
    return scannedItems.filter(item => item.status === 'Wareneingang' && !item.isCancelled).length;
}
// --- START DER √ÑNDERUNG: Die gesamte Funktion wird aktualisiert ---
function showOpenHusSummary() {
    removeActiveInlineNoteEditor();
    const shipments = loadShipments();
    
    const securityClearanceStatuses = ['XRY', 'ETD', 'EDD'];
    
    let openSecurityHusByOrder = [];
    let missingReceiptHusByOrder = [];
    let dunkelalarmItemsByOrder = {};

    Object.keys(shipments).forEach(baseNumber => {
        const shipment = shipments[baseNumber];
        
        if (shipment.scannedItems && shipment.scannedItems.length > 0) {
            const itemsWithDunkelalarm = shipment.scannedItems.filter(item => item.status === 'Dunkelalarm' && !item.isCancelled);
            if (itemsWithDunkelalarm.length > 0) {
                if (!dunkelalarmItemsByOrder[baseNumber]) dunkelalarmItemsByOrder[baseNumber] = { items: [], ...shipment };
                itemsWithDunkelalarm.forEach(item => dunkelalarmItemsByOrder[baseNumber].items.push(item));
            }
        }
        if (shipment.isHuListOrder && shipment.scannedItems && shipment.scannedItems.length > 0) {
            const allUniqueHusWithPos = Array.from(new Map(shipment.scannedItems.filter(i => i.rawInput).map(item => [item.rawInput, { hu: item.rawInput, position: item.position }])).values());
            const processedHus = new Set(shipment.scannedItems.filter(item => securityClearanceStatuses.includes(item.status) && !item.isCancelled).map(item => item.rawInput));
            const pendingSecurityHus = allUniqueHusWithPos.filter(item => !processedHus.has(item.hu));
            if (pendingSecurityHus.length > 0) openSecurityHusByOrder.push({ ...shipment, orderNumber: baseNumber, pendingHus: pendingSecurityHus, totalHus: allUniqueHusWithPos.length });
            const receiptHus = new Set(shipment.scannedItems.filter(item => item.status === 'Wareneingang' && !item.isCancelled).map(item => item.rawInput));
            const missingReceiptHus = allUniqueHusWithPos.filter(item => !receiptHus.has(item.hu));
            if (missingReceiptHus.length > 0) missingReceiptHusByOrder.push({ ...shipment, orderNumber: baseNumber, pendingHus: missingReceiptHus, totalHus: allUniqueHusWithPos.length, receiptCount: allUniqueHusWithPos.length - missingReceiptHus.length });
        }
    });

    const sortByCountryAndOrder = (a, b) => (a.destinationCountry || 'zz').localeCompare(b.destinationCountry || 'zz') || (a.orderNumber || a.hawb).localeCompare(b.orderNumber || b.hawb);
    
    const generateHuListHtml = (items) => {
        if (!items || items.length === 0) return '';
        const sortedItems = items.sort((a, b) => (a.position || 9999) - (b.position || 9999));
        const listItems = sortedItems.map(item => {
            const huValue = item.hu || item.rawInput; 

         const parentOrder = shipments[item.orderNumber] || shipments[Object.keys(shipments).find(key => shipments[key].scannedItems && shipments[key].scannedItems.some(i => i.rawInput === huValue))];
        const isManOrderContext = parentOrder && parentOrder.freightForwarder;
        
        // Pr√ºfe, ob f√ºr diese HU ein Dunkelalarm existiert
        const hasDunkelalarm = parentOrder && parentOrder.scannedItems.some(
            scan => scan.rawInput === huValue && scan.status === 'Dunkelalarm' && !scan.isCancelled
        );
        
        // Wende die rote Farbe an, falls ein Dunkelalarm existiert
        const huValueClass = hasDunkelalarm ? 'hu-value has-dunkelalarm' : 'hu-value';
        
        const positionHtml = isManOrderContext && item.position 
            ? `<span class="position-number">${item.position}.</span>` 
            : `<span class="position-number"></span>`;

        return `<li>${positionHtml}<span class="${huValueClass}">${escapeHtml(huValue)}</span></li>`;
        // --- ENDE DER NEUEN LOGIK ---
    }).join('');
    
    return `<ul class="hu-list">${listItems}</ul>`;
};
    
// INNERHALB der showOpenHusSummary Funktion

const generateHtmlForOrderGroup = (order, listItemsHtml, forDunkelalarm = false) => {
    const orderNumber = order.orderNumber || order.hawb;
    let countText = '';
    if (!forDunkelalarm) {
         countText = order.receiptCount !== undefined ? `(${order.receiptCount} von ${order.totalHus} erfasst)`: `(${(order.totalHus - order.pendingHus.length)} von ${order.totalHus} erfasst)`;
    }
    
    const isManOrder = order.freightForwarder && order.destinationCountry;
    const titlePrefix = isManOrder ? 'Rechnung: ' : '';
    let metaLineHtml = '';
    
    if (order.plsoNumber && order.plsoNumber !== 'N/A') {
        metaLineHtml += `<br><small>PLSO: ${escapeHtml(order.plsoNumber)}</small>`;
    }
    if (isManOrder) {
        // --- HIER IST DIE √ÑNDERUNG ---
        // Die K√ºrzungs-Funktion wird jetzt auch hier aufgerufen
        const shortForwarderName = shortenForwarderName(order.freightForwarder);
        metaLineHtml += `<br><small>Sped.: ${escapeHtml(shortForwarderName)} / Land: ${escapeHtml(order.destinationCountry)}</small>`;
        // --- ENDE DER √ÑNDERUNG ---
    }

    return `<div class="hu-order-group"><div class="hu-order-title">${titlePrefix}${escapeHtml(orderNumber)} ${countText}${metaLineHtml}</div>${listItemsHtml}</div>`;
};
    
    openSecurityHusByOrder.sort(sortByCountryAndOrder);
    missingReceiptHusByOrder.sort(sortByCountryAndOrder);
    const dunkelalarmArray = Object.values(dunkelalarmItemsByOrder).sort(sortByCountryAndOrder);

    openHusListContainerEl.innerHTML = openSecurityHusByOrder.map(order => generateHtmlForOrderGroup(order, generateHuListHtml(order.pendingHus))).join('') || '<p class="no-open-hus-message">Gl√ºckwunsch! Alle HUs sind sicherheitstechnisch bearbeitet.</p>';
    missingReceiptHusListContainerEl.innerHTML = missingReceiptHusByOrder.map(order => generateHtmlForOrderGroup(order, generateHuListHtml(order.pendingHus))).join('') || '<p class="no-open-hus-message">Perfekt! Alle HUs wurden im Wareneingang erfasst.</p>';
    dunkelalarmHusListContainerEl.innerHTML = dunkelalarmArray.map(data => generateHtmlForOrderGroup(data, generateHuListHtml(data.items), true)).join('') || '<p class="no-open-hus-message">Keine Eintr√§ge mit Status "Dunkelalarm" gefunden.</p>';

    // Rest der Funktion bleibt unver√§ndert
    showOpenSecurityHusBtnEl.classList.add('active');
    missingReceiptHusListContainerEl.style.display = 'none';
    openHusListContainerEl.style.display = 'block';
    showMissingReceiptHusBtnEl.classList.remove('active');
    dunkelalarmHusListContainerEl.style.display = 'none';
    showDunkelalarmHusBtnEl.classList.remove('active');
    openHusModalEl.classList.add('visible');
    document.body.classList.add('modal-open');
    closeSideMenu(); 
}        
        
        
        
        
        
        
// --- ENDE DER √ÑNDERUNG ---
// --- ENDE DER √ÑNDERUNG ---
        // --- START: NEUE HILFSFUNKTION ---
        function calculateXryKombiCount(scannedItems) {
            if (!Array.isArray(scannedItems)) return 0;
            // Z√§hlt nur nicht-stornierte Scans, die explizit als XRY Kombi markiert sind.
            return scannedItems.filter(item => 
                item.status === 'XRY' && 
                item.isCombination && 
                !item.isCancelled
            ).length;
        }
        // --- ENDE: NEUE HILFSFUNKTION ---

        function saveShipments(shipments) {
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(shipments));
        }
/**
 * Pr√ºft, ob eine HU-Nummer in irgendeinem HU-Listen-Auftrag existiert.
 * Spielt nur einen Ton, wenn √ºberhaupt HU-Listen-Auftr√§ge existieren.
 * @param {string} huNumber Die zu pr√ºfende HU-Nummer.
 * @returns {boolean} True, wenn die HU erwartet wird, sonst false.
 */
function isHuExpected(huNumber) {
    const upperHu = huNumber.trim().toUpperCase();
    if (!upperHu) return true;

    const shipments = loadShipments();
    let hasAnyHuListOrder = false; // Flag, um zu pr√ºfen, ob es √ºberhaupt Listen gibt

    // Zuerst pr√ºfen, ob es √ºberhaupt HU-Listen-Auftr√§ge gibt
    for (const baseNumber in shipments) {
        if (shipments[baseNumber].isHuListOrder) {
            hasAnyHuListOrder = true;
            break; // Sobald einer gefunden wurde, k√∂nnen wir die Schleife verlassen
        }
    }

    // --- HIER IST DIE NEUE LOGIK ---
    // Wenn es keine HU-Listen gibt, ist JEDE HU quasi "erwartet" (l√∂st keinen Fehler aus)
    if (!hasAnyHuListOrder) {
        return true;
    }
    // --- ENDE DER NEUEN LOGIK ---

    // Wenn es HU-Listen gibt, pr√ºfen wir jetzt, ob die HU auf einer davon steht
    for (const baseNumber in shipments) {
        const shipment = shipments[baseNumber];
        if (shipment.isHuListOrder && shipment.scannedItems) {
            if (shipment.scannedItems.some(item => item.rawInput.toUpperCase() === upperHu)) {
                return true; // Gefunden! HU wird erwartet.
            }
        }
    }
    
    // Die HU wurde in keiner der existierenden Listen gefunden. Sie ist "unerwartet".
    return false;
}
/**
 * K√ºrzt lange Spediteurnamen f√ºr eine saubere Anzeige basierend auf vordefinierten Regeln.
 * @param {string} fullName Der vollst√§ndige Name des Spediteurs.
 * @returns {string} Der gek√ºrzte Name oder der Originalname, falls keine Regel zutrifft.
 */
function shortenForwarderName(fullName) {
    if (!fullName) return ''; // Leere Eingaben abfangen

    const lowerCaseName = fullName.toLowerCase();

    if (lowerCaseName.includes('k√ºhne + nagel')) return 'K√ºhne + Nagel';
    if (lowerCaseName.includes('dhl global forwarding')) return 'DHL';
    if (lowerCaseName.includes('ups')) return 'UPS';
    if (lowerCaseName.includes('maersk') && lowerCaseName.includes('senator')) return 'Maersk/Senator';
    if (lowerCaseName.includes('freight consol')) return 'Freight Consol';
    if (lowerCaseName.includes('logwin')) return 'Logwin';
    if (lowerCaseName.includes('hartrodt')) return 'Hartrodt';
    if (lowerCaseName.includes('db schenker')) return 'DB Schenker';
    if (lowerCaseName.includes('ait worldwide')) return 'AIT Worldwide';
    if (lowerCaseName.includes('dachser')) return 'Dachser';
	if (lowerCaseName.includes('dsv')) return 'DSV';
    if (lowerCaseName.includes('hermes')) return 'HERMES';
    if (lowerCaseName.includes('wws freight')) return 'WWS';

    // Wenn keine Regel zutrifft, den Originalnamen zur√ºckgeben
    return fullName;
}
        // --- Hilfsfunktionen: UI & Fehler ---
        function clearError() { errorDisplayEl.textContent = ''; }
        function displayError(message, color = 'red', autoClearTimeout = null) {
            errorDisplayEl.textContent = message;
            errorDisplayEl.style.color = color;
            if (autoClearTimeout) {
                setTimeout(() => {
                    if (errorDisplayEl.textContent === message && errorDisplayEl.style.color === color) {
                        clearError();
                    }
                }, autoClearTimeout);
            }
        }
        function escapeHtml(unsafe) {
            if (unsafe === null || unsafe === undefined) return '';
            return unsafe.toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }

        function focusShipmentInput() {
            const isModalVisible = (sel) => document.querySelector(sel)?.classList.contains('visible');
            // ANFORDERUNG 2: Das neue HU-Import-Modal zur Pr√ºfung hinzuf√ºgen
            if (isModalVisible('#editModal') || isModalVisible('#batchNoteModal') || isModalVisible('#importHuModal') ||
                (sideMenuEl && sideMenuEl.classList.contains('open')) ||
                (newTotalSectionEl && newTotalSectionEl.classList.contains('visible')) ||
                document.querySelector('#currentShipmentDetails .inline-note-editor')) {
                return; // Kein Fokus, wenn ein Modal, Men√º oder Editor aktiv ist
            }
            if (shipmentNumberInputEl && !shipmentNumberInputEl.disabled) {
                shipmentNumberInputEl.inputMode = 'none'; // F√ºr Scanner
                setTimeout(() => shipmentNumberInputEl.focus(), 0);
            }
        }

        function processShipmentNumber(rawInput) {
            if (!rawInput) return { baseNumber: '', suffix: null, isValidFormat: false, raw: '', isSuffixFormat: false };
            const raw = rawInput.trim().toUpperCase();
            
            let baseNumber = '';
            let suffix = null;
            let isValidFormat = false;
            let isSuffixFormat = false; // <-- NEUES FELD
            
            const MIN_LENGTH_FOR_IMPLICIT_SUFFIX = 12;

            if (raw.includes('+')) {
                const parts = raw.split('+');
                if (parts.length === 2 && parts[0].length > 0 && parts[1].length === SUFFIX_LENGTH && /^\d+$/.test(parts[1])) {
                    baseNumber = parts[0];
                    suffix = parts[1];
                    isValidFormat = true;
                    isSuffixFormat = true; // <-- SETZEN
                }
            } 
            else if (raw.length >= MIN_LENGTH_FOR_IMPLICIT_SUFFIX && /\d{4}$/.test(raw.slice(-SUFFIX_LENGTH))) {
                suffix = raw.slice(-SUFFIX_LENGTH);
                let preSuffixPart = raw.slice(0, -SUFFIX_LENGTH);
                baseNumber = preSuffixPart.replace(/0+$/, '');
                if (baseNumber.length > 0) {
                    isValidFormat = true;
                    isSuffixFormat = true; // <-- SETZEN
                }
            } 
            else if (raw.length > 0) {
                baseNumber = raw;
                suffix = null;
                isValidFormat = true;
                isSuffixFormat = false; // <-- SETZEN
            }

            if (baseNumber.length === 0) {
                 isValidFormat = false;
            }

            return { baseNumber, suffix, isValidFormat, raw, isSuffixFormat }; // <-- NEUES FELD ZUR√úCKGEBEN
        }
        function findShipmentByNoteContent(searchText) {
            const shipments = loadShipments();
            const upperSearchText = searchText.trim().toUpperCase();
            if (!upperSearchText) return null;

            for (const baseNumber in shipments) {
                if (shipments.hasOwnProperty(baseNumber)) {
                    const shipment = shipments[baseNumber];
                    if (shipment.scannedItems && Array.isArray(shipment.scannedItems)) {
                        for (const item of shipment.scannedItems) {
                            // *** √ÑNDERUNG HIER ***
                            // √úberpr√ºft, ob das 'notes'-Array existiert und durchsucht es.
                            if (item.notes && Array.isArray(item.notes)) {
                                for (const note of item.notes) {
                                    if (note && note.trim().toUpperCase() === upperSearchText) {
                                        // Treffer gefunden! Gib die HAWB zur√ºck.
                                        return baseNumber;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return null; // Keine passende Notiz in keiner Sendung gefunden.
        }
        function findShipmentByHuNumber(huNumber) {
            const shipments = loadShipments();
            const upperHuNumber = huNumber.trim().toUpperCase();
            if (!upperHuNumber) return null;

            for (const baseNumber in shipments) {
                const shipment = shipments[baseNumber];
                // Suche nur in Auftr√§gen, die als HU-Listen-Auftrag markiert sind!
                if (shipment.isHuListOrder && shipment.scannedItems && Array.isArray(shipment.scannedItems)) {
                    const foundItem = shipment.scannedItems.find(item => item.rawInput.toUpperCase() === upperHuNumber);
                    if (foundItem) {
                        return baseNumber; // Treffer! Gib die HAWB/Auftragsnummer zur√ºck.
                    }
                }
            }
            return null; // Keine passende HU in keinem HU-Auftrag gefunden.
        }
        function calculateCurrentCountedPieces(scannedItems) {
            if (!Array.isArray(scannedItems)) return 0;
            return scannedItems.filter(item => !item.isCombination && !item.isCancelled && !NON_COUNTING_STATUSES.includes(item.status)).length;
        }

        function calculateStatusSummary(scannedItems) {
            const summary = {};
            if (!Array.isArray(scannedItems)) return summary;
            scannedItems.filter(item => !item.isCombination && !item.isCancelled && !NON_COUNTING_STATUSES.includes(item.status))
                .forEach(item => { summary[item.status] = (summary[item.status] || 0) + 1; });
            return summary;
        }

        // --- UI Update Funktionen ---
        function updateClearButtonVisibility(inputElement, clearButtonElement) {
            const el = inputElement || shipmentNumberInputEl;
            const btn = clearButtonElement || clearInputButtonEl;
            const hasText = el.value.trim() !== '';
            btn.style.display = (hasText && !el.disabled) ? 'block' : 'none';
        }

        function updateNoteAndComboVisibility() {
            const selectedStatus = securityStatusSelectEl.value;
            const showCombo = selectedStatus === 'XRY' && !isBatchModeActive;
            comboCheckboxContainerEl.classList.toggle('visible', showCombo);
            comboCheckboxContainerEl.style.display = showCombo ? 'flex' : 'none';
            comboCheckboxEl.disabled = !showCombo;
            if (!showCombo) comboCheckboxEl.checked = false;

            const showNoteButton = NOTE_ALLOWED_STATUSES.includes(selectedStatus) && !isBatchModeActive;
            noteToggleButtonEl.style.display = showNoteButton ? 'flex' : 'none';
            if (!showNoteButton) { // Wenn Button nicht sichtbar, Notizeingabe schlie√üen
                resetSingleScanNoteInputState();
            }
        }

        function resetSingleScanNoteInputState() {
            noteInputEl.value = '';
            noteInputContainerEl.style.display = 'none';
            noteToggleButtonEl.classList.remove('note-active');
            updateClearButtonVisibility(noteInputEl, clearNoteButtonEl);
        }
        
        function removeActiveInlineNoteEditor() {
            const activeEditor = currentDetailsDivEl.querySelector('.inline-note-editor');
            if (activeEditor) {
                const liElement = activeEditor.closest('li');
                activeEditor.remove();
                if (liElement) liElement.classList.remove('editing-note');
            }
        }

        // Hilfsfunktion zur Bestimmung der CSS-Klasse f√ºr Z√§hler
        function getStatusClass(count, expected) {
            // Wenn keine Erwartung gesetzt ist oder die Z√§hlung 0 ist, keine Farbe (Standard schwarz)
            if (expected === null || expected === undefined || count === 0) {
                return ''; 
            }
            if (count < expected) {
                return 'mismatch'; // Orange
            }
            if (count === expected) {
                return 'ok'; // Gr√ºn
            }
            if (count > expected) {
                return 'over'; // Rot
            }
            return ''; // Fallback
        }




        // Ersetzen Sie die komplette Funktion mit dieser Version
        
        
        
        
        
        
        
        
        
        
        
        
        
function displayCurrentShipmentDetails(baseNumberToDisplay) {
    clearError();
    removeActiveInlineNoteEditor();

    const shipments = loadShipments();
    const shipment = baseNumberToDisplay ? shipments[baseNumberToDisplay] : null;

    if (!baseNumberToDisplay || !shipment) {
        currentDetailsDivEl.innerHTML = 'Geben Sie eine Sendungsnummer ein oder w√§hlen Sie eine aus der Liste.';
        currentDetailsDivEl.style.borderColor = '#aac';
        return;
    }
    
    const isManOrder = shipment.freightForwarder && shipment.destinationCountry;
    let detailsHtml = '';
    
    if (shipment.isHuListOrder) {
        const titlePrefix = isManOrder ? 'Rechnung: ' : '';
        detailsHtml += `<strong>${titlePrefix}${escapeHtml(baseNumberToDisplay)}</strong>`;
        if (shipment.plsoNumber && shipment.plsoNumber !== 'N/A') {
            detailsHtml += `<div style="font-size: 0.9em; color: #555;">PLSO: ${escapeHtml(shipment.plsoNumber)}</div>`;
        }
        if (isManOrder) {
            const shortForwarderName = shortenForwarderName(shipment.freightForwarder);
            detailsHtml += `<div style="font-size: 0.9em; color: #555;">Sped.: ${escapeHtml(shortForwarderName)} / Land: ${escapeHtml(shipment.destinationCountry)}</div>`;
        }
        detailsHtml += `<hr style="border: none; border-top: 1px dotted #ccc; margin: 8px 0;">`;
    } else {
        detailsHtml = `<strong>Details f√ºr ${escapeHtml(baseNumberToDisplay)}:</strong>`;
    }

    if (shipment.isHuListOrder) {
        const securityClearanceStatuses = ['XRY', 'ETD', 'EDD'];
        const allUniqueHusWithPos = Array.from(new Map(shipment.scannedItems.filter(i => i.rawInput).map(item => [item.rawInput, { hu: item.rawInput, position: item.position }])).values());
        const processedHus = new Set(shipment.scannedItems.filter(item => securityClearanceStatuses.includes(item.status) && !item.isCancelled).map(item => item.rawInput));
        const pendingHuNumbers = allUniqueHusWithPos.filter(item => !processedHus.has(item.hu));
        if (pendingHuNumbers.length > 0) {
            const totalHus = allUniqueHusWithPos.length;
            const listClass = (totalHus - pendingHuNumbers.length > 0) ? 'partial' : '';
            detailsHtml += `<div id="pendingHuList" class="${listClass}"><h4>Offene HUs (${pendingHuNumbers.length} von ${totalHus}):</h4>`;
            const listItemsHtml = pendingHuNumbers.sort((a,b) => (a.position || 9999) - (b.position || 9999)).map(item => {
                const positionHtml = isManOrder && item.position ? `<span class="position-number">${item.position}.</span>` : `<span class="position-number"></span>`;
                return `<li>${positionHtml}<span class="hu-value">${escapeHtml(item.hu)}</span></li>`;
            }).join('');
            detailsHtml += `<ul class="hu-list">${listItemsHtml}</ul></div>`;
        }
    }
    
    detailsHtml += `<ul>`;
    (shipment.scannedItems || []).filter(item => item.status !== 'Anstehend').sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)).forEach(item => {
        const dt = new Date(item.timestamp);
        const timeStr = dt.toLocaleTimeString('de-DE');
        const dateStr = dt.toLocaleDateString('de-DE');
        const isCancelled = item.isCancelled;

        // --- HIER IST DIE NEUE HTML-STRUKTUR ---
        detailsHtml += `<li class="${isCancelled ? 'cancelled-item' : ''}">`;
        
        // Block 1: Hauptinformationen (erste Zeile)
        detailsHtml += `<div class="scan-main-info">`;
        detailsHtml += `<span class="timestamp">[${dateStr} ${timeStr}]</span> `;
        let numberPart = isManOrder && item.position ? `<span class="position-number">${item.position}.</span> ` : '';
        detailsHtml += `${numberPart}<span class="hu-value">${escapeHtml(item.rawInput)}</span> ‚Üí <span class="status">${escapeHtml(item.status)}</span>${item.isCombination ? ` <span class="combo">(Kombi)</span>` : ''}`;
        if (isCancelled) {
            const cancelDt = item.cancelledTimestamp ? new Date(item.cancelledTimestamp) : null;
            detailsHtml += `<span class="cancelled-info"> (storniert am ${cancelDt ? cancelDt.toLocaleString('de-DE') : 'Unbekannt'})</span>`;
        }
        detailsHtml += `</div>`; // Ende scan-main-info

        // Storno-Button bleibt au√üerhalb, damit er absolut positioniert werden kann
        if (!isCancelled) {
            detailsHtml += `<button class="cancel-button" data-basenumber="${escapeHtml(baseNumberToDisplay)}" data-timestamp="${item.timestamp}">Storno</button>`;
        }
        
        // Block 2: Notizen und Aktionen (zweite Zeile)
        detailsHtml += `<div class="scan-actions-and-notes">`;
        if (Array.isArray(item.notes) && item.notes.length > 0) {
            let notesListHtml = '<div class="notes-container">';
            item.notes.forEach((note, index) => {
                if (isCancelled) {
                    notesListHtml += `<div class="note-item" style="color:var(--cancelled-color);">- ${escapeHtml(note)}</div>`;
                } else {
                    notesListHtml += `<div class="note-item"><span class="note-prefix">Notiz:</span><span class="editable-note" data-basenumber="${escapeHtml(baseNumberToDisplay)}" data-timestamp="${item.timestamp}" data-note-index="${index}" title="Notiz bearbeiten">${escapeHtml(note)}</span><button class="delete-note-btn" data-basenumber="${escapeHtml(baseNumberToDisplay)}" data-timestamp="${item.timestamp}" data-note-index="${index}" title="Notiz l√∂schen">√ó</button></div>`;
                }
            });
            notesListHtml += '</div>';
            detailsHtml += notesListHtml;
        }
        if (!isCancelled) {
            detailsHtml += `<a href="#" class="add-note-link" data-basenumber="${escapeHtml(baseNumberToDisplay)}" data-timestamp="${item.timestamp}" title="Weitere Notiz hinzuf√ºgen">Notiz hinzuf√ºgen</a>`;
        }
        detailsHtml += `<div class="inline-note-editor-placeholder"></div>`;
        detailsHtml += `</div>`; // Ende scan-actions-and-notes
        
        detailsHtml += `</li>`;
        // --- ENDE DER NEUEN HTML-STRUKTUR ---
    });
    detailsHtml += `</ul>`;

    // Der Summary-Teil bleibt unver√§ndert
    const expected = shipment.totalPiecesExpected;
    const securityScansCount = calculateCurrentCountedPieces(shipment.scannedItems || []);
    const receiptScansCount = calculateGoodsReceiptCount(shipment.scannedItems || []);
    detailsHtml += `<div class="summary">`;
    let expectedText = (expected !== null && expected !== undefined) ? `${expected} Stk.` : 'N/A';
    const receiptClass = getStatusClass(receiptScansCount, expected);
    detailsHtml += `<span>Wareneingang: <span class="${receiptClass}">${receiptScansCount} von ${expectedText}</span></span>`;
    const securityClass = getStatusClass(securityScansCount, expected);
    detailsHtml += `<span>Sicherung erfasst: <span class="${securityClass}">${securityScansCount} von ${expectedText}</span></span>`;
    detailsHtml += `</div>`;
    
    currentDetailsDivEl.innerHTML = detailsHtml;

    // Die Logik f√ºr die Border-Farbe bleibt unver√§ndert
    if (expected !== null && expected !== undefined) {
        if (receiptScansCount > expected || securityScansCount > expected) currentDetailsDivEl.style.borderColor = 'red';
        else if (receiptScansCount < expected || securityScansCount < expected) currentDetailsDivEl.style.borderColor = 'orange';
        else if (receiptScansCount === expected && securityScansCount === expected) currentDetailsDivEl.style.borderColor = 'green';
        else currentDetailsDivEl.style.borderColor = '#aac';
    } else {
        currentDetailsDivEl.style.borderColor = '#aac';
    }
}
         function renderTable() {
            const shipments = loadShipments();
            tableBodyEl.innerHTML = '';
            Object.keys(shipments).sort((a, b) => new Date(shipments[b].lastModified || 0) - new Date(shipments[a].lastModified || 0))
                .forEach(baseNumber => {
                    const shipment = shipments[baseNumber];
                    if (!shipment) return;
                    const row = tableBodyEl.insertRow();
                    
                    const securityCount = calculateCurrentCountedPieces(shipment.scannedItems || []);
                    const receiptCount = calculateGoodsReceiptCount(shipment.scannedItems || []);
                    const expected = shipment.totalPiecesExpected;
                    const expectedText = expected ?? 'N/A';

                    row.insertCell().outerHTML = `<td data-label="HAWB.">${escapeHtml(baseNumber)}</td>`;

                    // Ruft die globale Hilfsfunktion f√ºr den Wareneingang auf
                    const receiptClass = getStatusClass(receiptCount, expected);

                    // --- START DER NEUEN LOGIK F√úR "Sicherungs"-FARBE ---
                    
                    // 1. Z√§hle die Dunkelalarme f√ºr diese Sendung (die Funktion existiert bereits)
                    const dunkelalarmCount = calculateDunkelalarmCount(shipment.scannedItems || []);
                    
                    let securityClass = ''; // Variable f√ºr die CSS-Klasse initialisieren

                    // 2. Pr√ºfe die neue Sonderbedingung:
                    // Wenn die Summe aus z√§hlenden Scans und Dunkelalarmen die Erwartung erf√ºllt UND es mindestens einen Dunkelalarm gibt...
                    if (expected !== null && (securityCount + dunkelalarmCount) === expected && dunkelalarmCount > 0) {
                        // ...dann setze die Farbe auf Rot (Klasse 'over').
                        securityClass = 'over'; 
                    } else {
                        // 3. Wenn die Sonderbedingung nicht zutrifft, verwende die alte, normale Logik.
                        securityClass = getStatusClass(securityCount, expected);
                    }
                    // --- ENDE DER NEUEN LOGIK ---

                    let summaryHtml = `
                        <strong class="${receiptClass}">WE: ${receiptCount}/${expectedText}</strong> | 
                        <strong class="${securityClass}">Sich.: ${securityCount}/${expectedText}</strong>
                    `;
                    
                    row.insertCell().outerHTML = `<td data-label="√úbersicht" class="summary-cell">${summaryHtml}</td>`;
                    
                    row.insertCell().outerHTML = `<td data-label="Letzte √Ñnd.">${shipment.lastModified ? new Date(shipment.lastModified).toLocaleString('de-DE') : '-'}</td>`;
                    
                    const actionsCell = row.insertCell();
                    actionsCell.setAttribute('data-label', 'Aktionen');
                    actionsCell.classList.add('actions-cell');
                    actionsCell.innerHTML = `
                        <button class="edit-btn" data-basenumber="${escapeHtml(baseNumber)}" title="Sendung ${escapeHtml(baseNumber)} bearbeiten">Edit</button>
                        <button class="pdf-btn" data-basenumber="${escapeHtml(baseNumber)}">PDF</button>
                        <button class="delete-btn main-delete-btn" data-basenumber="${escapeHtml(baseNumber)}">L√∂schen</button>
                    `;
                });
            updateEditButtonVisibilityInTable();
            filterTable(shipmentNumberInputEl.value);
        }
        function updateEditButtonVisibilityInTable() {
            // Dies wird √ºber CSS body.batch-mode-active td.actions-cell button.edit-btn { display: none; } gesteuert.
            // Diese Funktion k√∂nnte f√ºr komplexere Logik dienen, ist hier aber implizit durch CSS.
             document.body.classList.toggle('batch-mode-active', isBatchModeActive);
        }

        function filterTable(filterText) {
            const rows = tableBodyEl.getElementsByTagName('tr');
            const trimmedFilter = filterText ? filterText.trim().toUpperCase() : "";

            if (isBatchModeActive) { // Im Batch Mode alle Zeilen zeigen
                for (let row of rows) row.style.display = '';
                return;
            }
            if (trimmedFilter === "") { // Kein Filter, alle Zeilen zeigen
                for (let row of rows) row.style.display = '';
                return;
            }

            const inputParts = trimmedFilter.split('+');
            const inputBaseNumber = inputParts[0];
            const inputHasSuffix = inputParts.length > 1 && inputParts[1].length === SUFFIX_LENGTH && /^\d+$/.test(inputParts[1]);

            for (let row of rows) {
                const cell = row.cells[0];
                if (cell) {
                    const fullCellText = (cell.textContent || cell.innerText).toUpperCase();
                    const cellBaseNumber = fullCellText.split('+')[0].trim();
                    let showRow = false;
                    if (inputHasSuffix) { // Bei Suffix genaue √úbereinstimmung des Basenumbers
                        if (cellBaseNumber === inputBaseNumber) showRow = true;
                    } else { // Ohne Suffix, Pr√§fix-Suche
                        if (cellBaseNumber.startsWith(inputBaseNumber)) showRow = true;
                    }
                    row.style.display = showRow ? '' : 'none';
                }
            }
        }

        
        
        
        
        
        
        
      // ERSETZEN SIE DIESE GESAMTE FUNKTION
// ERSETZEN SIE DIESE GESAMTE FUNKTION
// ERSETZEN SIE DIESE GESAMTE FUNKTION
function processAndSaveSingleScan(rawInputToSave, statusToUse, isCombinationFromCheckbox) {
    const { baseNumber, suffix, isValidFormat, raw: processedRawInput, isSuffixFormat } = processShipmentNumber(rawInputToSave);
    if (!isValidFormat) { return { success: false, waitingForTotal: false, message: `Ung√ºltiges Format: ${escapeHtml(rawInputToSave)}` }; }

    const shipments = loadShipments();
    const parentHawb = findShipmentByHuNumber(processedRawInput);

    // --- START: √úberarbeitete Logik f√ºr HU-Listen-Auftr√§ge ---
    if (parentHawb) {
        const parentShipment = shipments[parentHawb];
        const now = new Date();
        const noteText = noteInputEl.value.trim() || null;
        const isNewScanKombi = (statusToUse === 'XRY' && isCombinationFromCheckbox);
        const isSecurityStatus = EXCLUSIVE_SECURITY_STATUSES.includes(statusToUse);
        
        const isFinalClearanceScan = isSecurityStatus && !isNewScanKombi;

        if (isFinalClearanceScan) {
            // FALL 1: Z√ÑHLENDER SCAN (XRY, ETD, EDD)
            const anstehendIndex = parentShipment.scannedItems.findIndex(
                i => i.rawInput.toUpperCase() === processedRawInput.toUpperCase() && i.status === 'Anstehend' && !i.isCancelled
            );

            if (anstehendIndex === -1) {
                return { success: false, waitingForTotal: false, message: `FEHLER: F√ºr HU ${escapeHtml(processedRawInput)} ist keine offene Sicherung mehr m√∂glich.` };
            }

            const itemToUpdate = parentShipment.scannedItems[anstehendIndex];
            itemToUpdate.status = statusToUse;
            itemToUpdate.timestamp = now.toISOString();
            itemToUpdate.isCombination = false;
            if (noteText) itemToUpdate.notes.push(noteText);

        } else {
            // FALL 2: NICHT-Z√ÑHLENDER SCAN (XRY (Kombi), Dunkelalarm, Wareneingang etc.)
            const existingItemIndex = parentShipment.scannedItems.findIndex(
                i => i.rawInput.toUpperCase() === processedRawInput.toUpperCase()
            );
            
            if (existingItemIndex === -1) {
                return { success: false, waitingForTotal: false, message: `FEHLER: HU ${escapeHtml(processedRawInput)} nicht im Auftrag ${parentHawb} gefunden.` };
            }
            
            // PR√úFUNG 1: Verhindert doppelte Kombi-Scans
            if (isNewScanKombi) {
                const hasExistingKombi = parentShipment.scannedItems.some(
                    item => item.rawInput.toUpperCase() === processedRawInput.toUpperCase() &&
                           item.isCombination && !item.isCancelled
                );
                if (hasExistingKombi) {
                    return { success: false, waitingForTotal: false, message: `FEHLER: F√ºr HU ${escapeHtml(processedRawInput)} wurde bereits eine Kombi-Sicherung erfasst.` };
                }
            }
            
            // PR√úFUNG 2: Verhindert doppelten Dunkelalarm
            if (statusToUse === 'Dunkelalarm') {
                const hasExistingDunkelalarm = parentShipment.scannedItems.some(
                    item => item.rawInput.toUpperCase() === processedRawInput.toUpperCase() &&
                           item.status === 'Dunkelalarm' && !item.isCancelled
                );
                if (hasExistingDunkelalarm) {
                    return { success: false, waitingForTotal: false, message: `FEHLER: F√ºr HU ${escapeHtml(processedRawInput)} wurde bereits ein Dunkelalarm erfasst.` };
                }
            }

            // --- NEUE PR√úFUNG 3: Verhindert doppelten Wareneingang ---
            if (statusToUse === 'Wareneingang') {
                const hasExistingReceipt = parentShipment.scannedItems.some(
                    item => item.rawInput.toUpperCase() === processedRawInput.toUpperCase() &&
                           item.status === 'Wareneingang' && !item.isCancelled
                );
                if (hasExistingReceipt) {
                    return { success: false, waitingForTotal: false, message: `FEHLER: F√ºr HU ${escapeHtml(processedRawInput)} wurde bereits der Wareneingang erfasst.` };
                }
            }
            // --- ENDE DER NEUEN PR√úFUNG ---
            
            const originalItem = parentShipment.scannedItems[existingItemIndex];

            const newItem = {
                rawInput: processedRawInput,
                status: statusToUse,
                timestamp: now.toISOString(),
                isCombination: isNewScanKombi,
                notes: noteText ? [noteText] : [],
                isCancelled: false,
                cancelledTimestamp: null,
                position: originalItem.position
            };
            parentShipment.scannedItems.push(newItem);
        }

        parentShipment.lastModified = now.toISOString();
        saveShipments(shipments);
        resetSingleScanNoteInputState();
        setTimeout(() => displayCurrentShipmentDetails(parentHawb), 0);
        return { success: true, waitingForTotal: false, message: `Vorgang '${statusToUse}${isNewScanKombi ? ' (Kombi)' : ''}' f√ºr HU ${escapeHtml(processedRawInput)} erfasst.` };
    }
    // --- ENDE: √úberarbeitete Logik f√ºr HU-Listen-Auftr√§ge ---

    // Die Logik f√ºr normale Sendungen (nicht aus HU-Listen) bleibt unver√§ndert.
    if (shipments[baseNumber] && shipments[baseNumber].isHuListOrder) {
        return { success: false, waitingForTotal: false, message: `FEHLER: ${baseNumber} ist ein HU-Auftrag. Bitte scannen Sie eine der zugeh√∂rigen HU-Nummern.` };
    }
    //... (der Rest der Funktion bleibt unver√§ndert) ...
    if (!shipments[baseNumber]) {
        const tempIsCombination = (statusToUse === 'XRY' && !isBatchModeActive && isCombinationFromCheckbox);
        const tempFinalIsCombination = NON_COUNTING_STATUSES.includes(statusToUse) ? false : tempIsCombination;
        pendingScanDataForNewShipment = { baseNumber, rawInput: processedRawInput, status: statusToUse, isCombination: tempFinalIsCombination, note: noteInputEl.value.trim() || null, timestamp: new Date().toISOString(), suffix };
        newTotalLabelEl.textContent = `Erwartete Gesamtst√ºckzahl f√ºr NEUE Sendung ${escapeHtml(baseNumber)}:`; newTotalInputEl.value = ''; newTotalSectionEl.classList.remove('warning-existing'); toggleMainInputControls(false); newTotalInputEl.focus();
        return { success: false, waitingForTotal: true, message: `Bitte Gesamtst√ºckzahl f√ºr ${escapeHtml(baseNumber)} eingeben oder √ºberspringen.` };
    }
    const shipment = shipments[baseNumber];
    const isCombination = (statusToUse === 'XRY' && isCombinationFromCheckbox);
    if (isSuffixFormat && !shipment.isHuListOrder) {
        const existingItemsForThisSuffix = shipment.scannedItems.filter(item => !item.isCancelled && item.rawInput.toUpperCase() === processedRawInput.toUpperCase());
        const isNewScanCounting = EXCLUSIVE_SECURITY_STATUSES.includes(statusToUse) && !isCombination;
        if (isNewScanCounting) {
            const existingCountingScan = existingItemsForThisSuffix.find(item => EXCLUSIVE_SECURITY_STATUSES.includes(item.status) && !item.isCombination);
            if (existingCountingScan) { return { success: false, message: `FEHLER: ${escapeHtml(processedRawInput)} hat bereits den z√§hlenden Status '${escapeHtml(existingCountingScan.status)}'.` }; }
        }
        if (isCombination) {
            const existingKombiScan = existingItemsForThisSuffix.find(item => item.isCombination);
            if (existingKombiScan) { return { success: false, message: `FEHLER: ${escapeHtml(processedRawInput)} wurde bereits als Kombi-Sicherung erfasst.` }; }
        }
        if (statusToUse === 'Dunkelalarm') {
            const existingDunkelalarm = existingItemsForThisSuffix.find(item => item.status === 'Dunkelalarm');
            if (existingDunkelalarm) { return { success: false, message: `FEHLER: ${escapeHtml(processedRawInput)} wurde bereits als Dunkelalarm erfasst.` }; }
        }
    }
    const expectedTotal = shipment.totalPiecesExpected;
    const existingNonCancelled = (shipment.scannedItems || []).filter(item => !item.isCancelled);
    if (isCombination && !shipment.isHuListOrder && expectedTotal !== null) {
        const xryKombiCount = calculateXryKombiCount(existingNonCancelled);
        if (xryKombiCount >= expectedTotal) { return { success: false, waitingForTotal: false, message: `Limit (${expectedTotal}) f√ºr XRY Kombi bei ${baseNumber} erreicht.` }; }
    }
    if (statusToUse === 'Dunkelalarm' && !isSuffixFormat && !shipment.isHuListOrder && expectedTotal !== null) {
        const dunkelalarmCount = calculateDunkelalarmCount(existingNonCancelled);
        if (dunkelalarmCount >= expectedTotal) {
            return { success: false, waitingForTotal: false, message: `Limit (${expectedTotal}) f√ºr Dunkelalarm bei ${baseNumber} erreicht.` };
        }
    }
    if (statusToUse === 'Wareneingang' && expectedTotal !== null && calculateGoodsReceiptCount(existingNonCancelled) >= expectedTotal) {
        return { success: false, waitingForTotal: false, message: `Limit (${expectedTotal}) f√ºr Wareneingang bei ${baseNumber} erreicht.` };
    }
    if (!isCombination && !NON_COUNTING_STATUSES.includes(statusToUse) && expectedTotal !== null && calculateCurrentCountedPieces(existingNonCancelled) >= expectedTotal) {
        return { success: false, waitingForTotal: false, message: `Limit (${expectedTotal}) f√ºr normale Scans bei ${baseNumber} erreicht.` };
    }
    const now = new Date();
    const noteText = noteInputEl.value.trim() || null;
    const newItem = { rawInput: processedRawInput, status: statusToUse, timestamp: now.toISOString(), isCombination, notes: noteText ? [noteText] : [], isCancelled: false, cancelledTimestamp: null };
    shipment.scannedItems.push(newItem);
    shipment.lastModified = now.toISOString();
    saveShipments(shipments);
    resetSingleScanNoteInputState();
    const updatedShipment = loadShipments()[baseNumber];
    if (updatedShipment) {
        const finalCount = calculateCurrentCountedPieces(updatedShipment.scannedItems);
        if (updatedShipment.totalPiecesExpected !== null && finalCount === updatedShipment.totalPiecesExpected && !notifiedCompletions.has(baseNumber)) {
            notifyShipmentCompletion(updatedShipment);
        }
    }
    return { success: true, waitingForTotal: false, message: `${processedRawInput} (${statusToUse}) zu ${baseNumber} hinzugef√ºgt.` };
}
        
        
        
        
        
        
            // --- ANFANG DER √ÑNDERUNG F√úR BUTTON-LOGIK ---
            function resetNewTotalSectionUI() {
                toggleMainInputControls(true);
                newTotalSectionEl.classList.remove('warning-existing');
                shipmentNumberInputEl.value = '';
                updateClearButtonVisibility(shipmentNumberInputEl, clearInputButtonEl);
                focusShipmentInput();
            }
            
            confirmNewTotalBtnEl.addEventListener('click', () => {
                if (pendingTotalUpdateInfo) {
                    // Fall: Bestehende Sendung aktualisieren
                    const baseNumber = pendingTotalUpdateInfo.baseNumber;
                    const newTotalExpectedStr = newTotalInputEl.value.trim();
                    let newTotalExpected = null;

                    if (newTotalExpectedStr !== '') {
                        const parsedNum = parseInt(newTotalExpectedStr, 10);
                        if (!isNaN(parsedNum) && parsedNum > 0) {
                            newTotalExpected = parsedNum;
                        } else {
                            alert("Ung√ºltige Eingabe f√ºr St√ºckzahl. Bitte eine positive Zahl eingeben oder Feld leer lassen.");
                            newTotalInputEl.focus();
                            return;
                        }
                    }

                    const shipments = loadShipments();
                    if (shipments[baseNumber]) {
                        shipments[baseNumber].totalPiecesExpected = newTotalExpected;
                        shipments[baseNumber].lastModified = new Date().toISOString();
                        saveShipments(shipments);
                        displayError(`St√ºckzahl f√ºr ${escapeHtml(baseNumber)} aktualisiert.`, 'green', 3000);
                        renderTable();
                        displayCurrentShipmentDetails(baseNumber);
                    }
                    pendingTotalUpdateInfo = null; // Status zur√ºcksetzen
                    resetNewTotalSectionUI();

                } else {
                    // Fall: Neue Sendung erstellen (bisherige Logik)
                    completeNewShipmentSave(newTotalInputEl.value);
                }
            });

            skipNewTotalBtnEl.addEventListener('click', () => {
                if (pendingTotalUpdateInfo) {
                    // Fall: Aktualisierung einer bestehenden Sendung abbrechen
                    displayError('Aktualisierung abgebrochen.', 'orange', 2000);
                    pendingTotalUpdateInfo = null; // Status zur√ºcksetzen
                    resetNewTotalSectionUI();
                    displayCurrentShipmentDetails(shipmentNumberInputEl.value); // Zeige Details der urspr√ºnglichen Eingabe
                } else {
                    // Fall: Neue Sendung ohne St√ºckzahl erstellen (bisherige Logik)
                    completeNewShipmentSave(null);
                }
            });
            // --- ENDE DER √ÑNDERUNG F√úR BUTTON-LOGIK ---

            newTotalInputEl.addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); confirmNewTotalBtnEl.click(); }});
        function completeNewShipmentSave(totalValueInput) {
            if (!pendingScanDataForNewShipment) {
                toggleMainInputControls(true); return;
            }
            let totalExpectedPieces = null;
            if (totalValueInput !== null && totalValueInput.trim() !== '') {
                const parsedTotal = parseInt(totalValueInput, 10);
                if (!isNaN(parsedTotal) && parsedTotal > 0) {
                    totalExpectedPieces = parsedTotal;
                } else {
                    alert("Ung√ºltige Eingabe f√ºr St√ºckzahl. Wird als 'N/A' gespeichert.");
                }
            }

            const shipments = loadShipments();
            const { baseNumber, rawInput, status, isCombination, note, timestamp } = pendingScanDataForNewShipment;
            
            shipments[baseNumber] = {
                hawb: baseNumber,
                lastModified: timestamp,
                totalPiecesExpected: totalExpectedPieces,
                scannedItems: [],
                mitarbeiter: MITARBEITER_NAME
            };
        const newScanItem = {
            rawInput, status, timestamp, isCombination,
            notes: note ? [note] : [], // Notiz als Array speichern
            isCancelled: false, cancelledTimestamp: null
        };
            shipments[baseNumber].scannedItems.push(newScanItem);
            saveShipments(shipments);

            toggleMainInputControls(true);
            resetSingleScanNoteInputState();
            shipmentNumberInputEl.value = '';
            updateClearButtonVisibility(shipmentNumberInputEl, clearInputButtonEl);
            renderTable();
            displayCurrentShipmentDetails(baseNumber);
            
            const totalMsgPart = totalExpectedPieces !== null ? ` mit ${totalExpectedPieces} erwarteten Stk.` : '';
            displayError(`${escapeHtml(rawInput)} hinzugef√ºgt (Sendung ${escapeHtml(baseNumber)} neu erstellt${totalMsgPart}).`, 'green', 3000);

            const finalCount = calculateCurrentCountedPieces(shipments[baseNumber].scannedItems);
            if (totalExpectedPieces !== null && finalCount === totalExpectedPieces && !notifiedCompletions.has(baseNumber)) {
                notifyShipmentCompletion(shipments[baseNumber]);
            }
            pendingScanDataForNewShipment = null;
            focusShipmentInput();
        }

        function toggleMainInputControls(showMain) {
            const mainControls = [securityStatusSelectEl, comboCheckboxContainerEl, mainActionButtonEl, noteToggleButtonEl];
            if (showMain) {
                mainControls.forEach(el => { if(el) el.style.display = '';}); // NoteToggleButton wird durch updateNoteAndComboVisibility gesteuert
                updateNoteAndComboVisibility(); // Stellt sicher, dass Note-Toggle-Button und Kombi korrekt angezeigt werden
                newTotalSectionEl.classList.remove('visible');
                newTotalSectionEl.style.display = 'none';
                shipmentNumberInputEl.disabled = false;
            } else { // NewTotal Section wird angezeigt
                mainControls.forEach(el => { if(el) el.style.display = 'none';});
                if(noteInputContainerEl) noteInputContainerEl.style.display = 'none'; // Auch das Einzelnotizfeld ausblenden
                newTotalSectionEl.classList.add('visible');
                newTotalSectionEl.style.display = 'flex';
                shipmentNumberInputEl.disabled = true;
                // shipmentNumberInputEl.value = ''; // Wert nicht unbedingt leeren, da er zur Anzeige in NewTotalLabel verwendet wird
                updateClearButtonVisibility(shipmentNumberInputEl, clearInputButtonEl);
            }
        }


      function showInlineNoteEditor(targetElement) {
            removeActiveInlineNoteEditor(); // Zuerst bestehenden Editor entfernen

            const liElement = targetElement.closest('li');
            if (!liElement) return;

            const baseNumber = targetElement.dataset.basenumber;
            const itemTimestamp = targetElement.dataset.timestamp;
            const noteIndex = targetElement.dataset.noteIndex; // Kann undefined sein (beim Hinzuf√ºgen)
            const isEditing = noteIndex !== undefined;
            const currentNote = isEditing ? liElement.querySelector(`.editable-note[data-note-index="${noteIndex}"]`).textContent : '';

            // Editor nach "Notiz hinzuf√ºgen" oder nach der Notizliste einf√ºgen
            const placeholderDiv = liElement.querySelector('.inline-note-editor-placeholder');
            if (!placeholderDiv) return;

            liElement.classList.add('editing-note'); // Versteckt Links, w√§hrend editiert wird

            const editorHtml = `
                <div class="inline-note-editor">
                    <input type="text" class="inline-note-input" value="${escapeHtml(currentNote)}" placeholder="Notiz eingeben...">
                    <div class="inline-note-editor-actions">
                        <button class="inline-note-save-btn" data-basenumber="${escapeHtml(baseNumber)}" data-timestamp="${itemTimestamp}" ${isEditing ? `data-note-index="${noteIndex}"` : ''}>Speichern</button>
                        <button class="inline-note-cancel-btn">Abbrechen</button>
                    </div>
                </div>`;
            placeholderDiv.innerHTML = editorHtml;

            const inputField = placeholderDiv.querySelector('.inline-note-input');
            if (inputField) {
                inputField.focus(); inputField.select();
                inputField.addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); placeholderDiv.querySelector('.inline-note-save-btn')?.click(); }});
                inputField.addEventListener('keydown', (e) => { if (e.key === 'Escape') { e.preventDefault(); placeholderDiv.querySelector('.inline-note-cancel-btn')?.click(); }});
            }
        }

        function saveOrUpdateNote(baseNumber, itemTimestamp, noteIndex, newNoteValue) {
            const shipments = loadShipments();
            const shipment = shipments[baseNumber];
            if (!shipment || !shipment.scannedItems) return;

            const item = shipment.scannedItems.find(i => i.timestamp === itemTimestamp);
            if (!item) return;

            const noteText = newNoteValue.trim();
            const isEditing = noteIndex !== undefined && noteIndex !== null;

            if (isEditing) { // Bearbeiten einer existierenden Notiz
                if (noteText) {
                    item.notes[noteIndex] = noteText; // Aktualisieren
                } else {
                    item.notes.splice(noteIndex, 1); // L√∂schen, wenn leer gespeichert wird
                }
            } else { // Hinzuf√ºgen einer neuen Notiz
                if (noteText) {
                    if (!Array.isArray(item.notes)) item.notes = [];
                    item.notes.push(noteText);
                }
            }

            shipment.lastModified = new Date().toISOString();
            saveShipments(shipments);
            displayCurrentShipmentDetails(baseNumber); // UI neu zeichnen
            focusShipmentInput();
        }

        function requestDeleteNote(baseNumber, itemTimestamp, noteIndex) {
            const shipments = loadShipments();
            const noteToDelete = shipments[baseNumber]?.scannedItems?.find(i => i.timestamp === itemTimestamp)?.notes[noteIndex];
            if(confirm(`Notiz "${noteToDelete}" wirklich l√∂schen?`)) {
                 const item = shipments[baseNumber].scannedItems.find(i => i.timestamp === itemTimestamp);
                 item.notes.splice(noteIndex, 1);
                 shipments[baseNumber].lastModified = new Date().toISOString();
                 saveShipments(shipments);
                 displayCurrentShipmentDetails(baseNumber);
                 focusShipmentInput();
            }
        }

        function toggleBatchMode(activate) {
            isBatchModeActive = activate;
            clearError();
            resetSingleScanNoteInputState();
            updateNoteAndComboVisibility(); // Combo und Einzelnotiz-Button aktualisieren
            document.body.classList.toggle('batch-mode-active', isBatchModeActive);


            if (isBatchModeActive) {
                batchStatus = securityStatusSelectEl.value;
                // Kombi-Checkbox-Status f√ºr Batch bei Aktivierung √ºbernehmen
                batchIsCombination = (securityStatusSelectEl.value === 'XRY' && comboCheckboxEl.checked);
                const comboText = batchIsCombination ? ' (Kombi)' : '';
                const statusLabel = `${batchStatus}${comboText}`;

                batchModeStatusLabelEl.textContent = statusLabel;
                batchStatusDisplayEl.textContent = `Aktiv (${statusLabel})`;
                mainActionButtonEl.textContent = 'Zum Batch hinzuf√ºgen';
                batchAreaEl.classList.add('visible');
                securityStatusSelectEl.disabled = true;
                comboCheckboxEl.disabled = true; // Auch Kombi-Checkbox im Batch sperren
                
                batchNoteToggleEl.checked = false; // <-- HIER IST DIE HINZUGEF√úGTE ZEILE
                currentBatch = [];
                currentBatchGlobalNote = null;
                isBatchNotePromptRequired = true; // Batch-Notiz-Modal soll beim ersten Scan im neuen Batch kommen
                pendingFirstBatchScanData = null;
                updateBatchUI();
                displayCurrentShipmentDetails(''); // Keine Details im Batch Modus anzeigen
            } else {
                if (currentBatch.length > 0) {
                    if (!confirm("Batch-Modus deaktivieren? Nicht gespeicherte Scans im aktuellen Batch gehen verloren!")) {
                        batchModeToggleEl.checked = true; // Zur√ºcksetzen, wenn User abbricht
                        isBatchModeActive = true; // Status beibehalten
                        document.body.classList.toggle('batch-mode-active', true);
                        return;
                    }
                }
                batchStatusDisplayEl.textContent = 'Inaktiv';
                mainActionButtonEl.textContent = 'Hinzuf√ºgen';
                batchAreaEl.classList.remove('visible');
                securityStatusSelectEl.disabled = false;
                comboCheckboxEl.disabled = securityStatusSelectEl.value !== 'XRY'; // Entsperren, wenn XRY
                currentBatch = [];
                updateBatchUI();
                // Ggf. Details der aktuellen Eingabe wieder anzeigen
                displayCurrentShipmentDetails(processShipmentNumber(shipmentNumberInputEl.value).baseNumber);
            }
            toggleMainInputControls(true); // Generelle UI-Controls (de)aktivieren
            updateEditButtonVisibilityInTable();
            filterTable(shipmentNumberInputEl.value);
            focusShipmentInput();
        }

        function updateBatchUI() {
            batchListEl.innerHTML = '';
            currentBatch.forEach((batchItem, index) => {
                const li = document.createElement('li');
                const itemDate = new Date(batchItem.scanTimestamp);
                let displayText = `${escapeHtml(batchItem.rawInput)} (${itemDate.toLocaleTimeString('de-DE')})`;
                if (batchItem.note) {
                    displayText += ` - Notiz: ${escapeHtml(batchItem.note)}`;
                }
                li.textContent = displayText;
                const removeBtn = document.createElement('button');
                removeBtn.textContent = 'X';
                removeBtn.classList.add('remove-batch-item');
                removeBtn.title = `${escapeHtml(batchItem.rawInput)} aus Batch entfernen`;
                removeBtn.onclick = () => {
                    currentBatch.splice(index, 1);
                    updateBatchUI();
                    if (currentBatch.length === 0) { // Wenn Batch leer wird
                        isBatchNotePromptRequired = true; // F√ºr n√§chsten Batch wieder Modal
                        currentBatchGlobalNote = null;
                        updateCurrentBatchNoteDisplay();
                    }
                };
                li.appendChild(removeBtn);
                batchListEl.appendChild(li);
            });
            batchItemCountEl.textContent = currentBatch.length;
            updateCurrentBatchNoteDisplay();
        }
        
        function updateCurrentBatchNoteDisplay() {
            if (isBatchModeActive && currentBatchGlobalNote) {
                currentBatchNoteDisplayEl.textContent = `Batch-Notiz: ${escapeHtml(currentBatchGlobalNote)}`;
                currentBatchNoteDisplayEl.style.display = 'block';
            } else {
                currentBatchNoteDisplayEl.textContent = '';
                currentBatchNoteDisplayEl.style.display = 'none';
            }
        }

        function addToBatch() {
    const rawInputFromField = shipmentNumberInputEl.value.trim();
    if (!rawInputFromField) { focusShip-mentInput(); return; }

    const upperRawInput = rawInputFromField.toUpperCase();
    const { isValidFormat, raw: processedRawInput } = processShipmentNumber(upperRawInput);
    if (!isValidFormat) {
        displayError(`Ung√ºltiges Format f√ºr Batch-Eingabe: ${escapeHtml(rawInputFromField)}`);
        focusShipmentInput();
        return;
    }

    const scanTimestamp = new Date().toISOString();

    if (unexpectedHuSoundToggleEl && unexpectedHuSoundToggleEl.checked) {
        if (!isHuExpected(processedRawInput)) {
            if(errorSoundEl) {
                errorSoundEl.play().catch(e => console.warn("Audio playback failed:", e));
            }
        }
    }

    if (isBatchModeActive && currentBatch.length === 0 && isBatchNotePromptRequired && batchNoteToggleEl.checked) {
        pendingFirstBatchScanData = { rawInput: processedRawInput, scanTimestamp: scanTimestamp };
        batchNoteInputEl.value = currentBatchGlobalNote || ''; 
        batchNoteModalEl.classList.add('visible');
        document.body.classList.add('modal-open');
        batchNoteInputEl.focus();
        return;
    }

    const batchItem = {
        rawInput: processedRawInput,
        scanTimestamp: scanTimestamp,
        note: currentBatchGlobalNote 
    };
    
    // --- HIER IST DIE EINZIGE √ÑNDERUNG ---
    // Anstatt .push() verwenden wir .unshift(), um das Element am Anfang hinzuzuf√ºgen.
    currentBatch.unshift(batchItem);
    // --- ENDE DER √ÑNDERUNG ---
    
    updateBatchUI();
    shipmentNumberInputEl.value = '';
    updateClearButtonVisibility(shipmentNumberInputEl, clearInputButtonEl);
    clearError();
    focusShipmentInput();
}
// --- ERSETZEN Sie die alte Funktion durch diese Version ---

        function confirmAndAddFirstBatchItemWithNote() {
            const newNote = batchNoteInputEl.value.trim() || null;
            currentBatchGlobalNote = newNote;
            currentBatch.forEach(item => { item.note = newNote; });
            isBatchNotePromptRequired = false;
            batchNoteModalEl.classList.remove('visible');
            document.body.classList.remove('modal-open'); // NEU
            updateBatchUI();
            batchNoteToggleEl.checked = false;

            if (pendingFirstBatchScanData) {
                const batchItem = { ...pendingFirstBatchScanData, note: currentBatchGlobalNote };
                currentBatch.push(batchItem);
                pendingFirstBatchScanData = null;
                updateBatchUI();
                shipmentNumberInputEl.value = '';
                updateClearButtonVisibility(shipmentNumberInputEl, clearInputButtonEl);
            }
            clearError();
            focusShipmentInput();
        }

function skipNoteAndAddFirstBatchItem() {
            currentBatchGlobalNote = null;
            currentBatch.forEach(item => { item.note = null; });
            isBatchNotePromptRequired = false;
            
            batchNoteModalEl.classList.remove('visible');
            document.body.classList.remove('modal-open'); // <-- DIESE ZEILE IST NEU/KORRIGIERT

            updateBatchUI();
            batchNoteToggleEl.checked = false;

            if (pendingFirstBatchScanData) {
                const batchItem = { ...pendingFirstBatchScanData, note: null };
                currentBatch.push(batchItem);
                pendingFirstBatchScanData = null;
                updateBatchUI();
                shipmentNumberInputEl.value = '';
                updateClearButtonVisibility(shipmentNumberInputEl, clearInputButtonEl);
            }
            clearError();
            focusShipmentInput();
        }

// --- ERSETZEN Sie die alte Funktion durch diese Version ---

        function skipNoteAndAddFirstBatchItem() {
            currentBatchGlobalNote = null; // Globale Notiz f√ºr zuk√ºnftige Scans entfernen

            // *** DIE WICHTIGE NEUE LOGIK ***
            // Entferne die Notiz von ALLEN bereits vorhandenen Items im Batch
            currentBatch.forEach(item => {
                item.note = null;
            });
            // *******************************
            
            isBatchNotePromptRequired = false;
            batchNoteModalEl.classList.remove('visible');
            updateBatchUI(); // UI aktualisieren, um die entfernten Notizen zu reflektieren
            batchNoteToggleEl.checked = false; // Schalter nach Benutzung immer deaktivieren

            // Nur wenn ein Scan auf die Verarbeitung wartet, wird er hinzugef√ºgt.
            if (pendingFirstBatchScanData) {
                const batchItem = { ...pendingFirstBatchScanData, note: null };
                currentBatch.push(batchItem);
                pendingFirstBatchScanData = null;
                updateBatchUI(); // UI erneut aktualisieren
                shipmentNumberInputEl.value = '';
                updateClearButtonVisibility(shipmentNumberInputEl, clearInputButtonEl);
            }
            clearError();
            focusShipmentInput();
        }

        function saveBatch() {
            if (currentBatch.length === 0) { displayError("Batch ist leer."); focusShipmentInput(); return; }
            
            let successCount = 0;
            let errorCount = 0;
            let errorMessages = [];
            let newBaseShipments = new Set();
            let affectedBaseNumbersForNotification = new Set();

            const shipmentsWorkingCopy = JSON.parse(JSON.stringify(loadShipments()));

            currentBatch.forEach(batchItem => {
                const { rawInput: rawInputFromBatch, scanTimestamp, note: itemNote } = batchItem;
                
                const parentHawb = findShipmentByHuNumber(rawInputFromBatch);
                if (parentHawb) {
                    const parentShipment = shipmentsWorkingCopy[parentHawb];
                    const isNewScanKombi = (batchStatus === 'XRY' && batchIsCombination);
                    const isSecurityStatus = EXCLUSIVE_SECURITY_STATUSES.includes(batchStatus);
                    
                    // --- START DER KORREKTUR ---
                    const packageLimit = parentShipment.scannedItems.filter(
                        item => item.rawInput.toUpperCase() === rawInputFromBatch.toUpperCase() &&
                               (item.status === 'Anstehend' || (EXCLUSIVE_SECURITY_STATUSES.includes(item.status) && !item.isCombination))
                    ).length;

                    if (isNewScanKombi) {
                        const currentKombiCount = parentShipment.scannedItems.filter(
                            item => item.rawInput.toUpperCase() === rawInputFromBatch.toUpperCase() &&
                                   !item.isCancelled && item.isCombination
                        ).length;
                        if (currentKombiCount >= packageLimit) {
                            errorCount++; errorMessages.push(`Kombi-Limit (${packageLimit}) f√ºr HU ${rawInputFromBatch} erreicht.`); return;
                        }
                        const newScanItem = {
                            rawInput: rawInputFromBatch, status: batchStatus, timestamp: scanTimestamp,
                            isCombination: true, notes: itemNote ? [itemNote] : [],
                            isCancelled: false, cancelledTimestamp: null
                        };
                        parentShipment.scannedItems.push(newScanItem);

                    } else if (isSecurityStatus) {
                        const anstehendIndex = parentShipment.scannedItems.findIndex(
                            i => i.rawInput.toUpperCase() === rawInputFromBatch.toUpperCase() && i.status === 'Anstehend'
                        );
                        if (anstehendIndex === -1) {
                            errorCount++; errorMessages.push(`Alle (${packageLimit}) Packst√ºcke f√ºr HU ${rawInputFromBatch} bereits final erfasst.`); return;
                        }
                        const itemToUpdate = parentShipment.scannedItems[anstehendIndex];
                        itemToUpdate.status = batchStatus; itemToUpdate.timestamp = scanTimestamp;
                        itemToUpdate.isCombination = false; itemToUpdate.notes = itemNote ? [itemNote] : [];
                        itemToUpdate.isCancelled = false; itemToUpdate.cancelledTimestamp = null;
                        
                    } else {
                        const currentStatusCount = parentShipment.scannedItems.filter(
                            item => item.rawInput.toUpperCase() === rawInputFromBatch.toUpperCase() && 
                                   item.status === batchStatus && !item.isCancelled
                        ).length;
                        if (currentStatusCount >= packageLimit) {
                            errorCount++; errorMessages.push(`Limit (${packageLimit}) f√ºr Status '${batchStatus}' bei HU ${rawInputFromBatch} erreicht.`); return;
                        }
                        const newScanItem = {
                            rawInput: rawInputFromBatch, status: batchStatus, timestamp: scanTimestamp,
                            isCombination: false, notes: itemNote ? [itemNote] : [],
                            isCancelled: false, cancelledTimestamp: null
                        };
                        parentShipment.scannedItems.push(newScanItem);
                    }
                    // --- ENDE DER KORREKTUR ---
                    
                    parentShipment.lastModified = scanTimestamp;
                    affectedBaseNumbersForNotification.add(parentHawb);
                    successCount++;
                    return;
                }
                
                const { baseNumber, isValidFormat, raw: processedRawInput, isSuffixFormat } = processShipmentNumber(rawInputFromBatch);
                if (!isValidFormat) {
                    errorCount++; errorMessages.push(`Ung√ºltiges Format: ${escapeHtml(rawInputFromBatch)}`); return;
                }
                if (!shipmentsWorkingCopy[baseNumber]) {
                    newBaseShipments.add(baseNumber);
                    shipmentsWorkingCopy[baseNumber] = {
                        hawb: baseNumber, lastModified: scanTimestamp, totalPiecesExpected: null,
                        scannedItems: [], mitarbeiter: MITARBEITER_NAME
                    };
                }
                const shipmentToUpdate = shipmentsWorkingCopy[baseNumber];
                if (isSuffixFormat && !shipmentToUpdate.isHuListOrder) {
                    const existingItemsForThisSuffix = shipmentToUpdate.scannedItems.filter(item => 
                        !item.isCancelled &&
                        item.rawInput.toUpperCase() === processedRawInput.toUpperCase()
                    );
                    const isBatchScanCounting = EXCLUSIVE_SECURITY_STATUSES.includes(batchStatus) && !batchIsCombination;
                    if (isBatchScanCounting) {
                        const existingCountingScan = existingItemsForThisSuffix.find(item => 
                            EXCLUSIVE_SECURITY_STATUSES.includes(item.status) && !item.isCombination
                        );
                        if (existingCountingScan) {
                            errorCount++; errorMessages.push(`${escapeHtml(processedRawInput)}: hat bereits Status '${escapeHtml(existingCountingScan.status)}'`); return;
                        }
                    }
                    const isBatchScanKombi = batchStatus === 'XRY' && batchIsCombination;
                    if (isBatchScanKombi) {
                        const existingKombiScan = existingItemsForThisSuffix.find(item => item.isCombination);
                        if (existingKombiScan) {
                            errorCount++; errorMessages.push(`${escapeHtml(processedRawInput)}: bereits als Kombi erfasst`); return;
                        }
                    }
                    if (batchStatus === 'Dunkelalarm') {
                        const existingDunkelalarm = existingItemsForThisSuffix.find(item => item.status === 'Dunkelalarm');
                        if (existingDunkelalarm) {
                             errorCount++; errorMessages.push(`${escapeHtml(processedRawInput)}: bereits als Dunkelalarm erfasst`); return;
                        }
                    }
                }
                const expectedTotal = shipmentToUpdate.totalPiecesExpected;
                const isCurrentBatchItemCounting = !NON_COUNTING_STATUSES.includes(batchStatus) && !batchIsCombination;
                if (isCurrentBatchItemCounting && expectedTotal !== null) {
                    const currentCountInWorkingCopy = calculateCurrentCountedPieces(shipmentToUpdate.scannedItems);
                    if (currentCountInWorkingCopy >= expectedTotal) {
                        errorCount++; errorMessages.push(`Limit (${expectedTotal}) f√ºr ${escapeHtml(baseNumber)} erreicht bei Scan ${escapeHtml(processedRawInput)}`); return;
                    }
                }
                const newScanItem = {
                    rawInput: processedRawInput, status: batchStatus, timestamp: scanTimestamp,
                    isCombination: batchIsCombination, notes: itemNote ? [itemNote] : [],
                    isCancelled: false, cancelledTimestamp: null
                };
                shipmentToUpdate.scannedItems.push(newScanItem);
                shipmentToUpdate.lastModified = scanTimestamp;
                affectedBaseNumbersForNotification.add(baseNumber);
                successCount++;
            });

            saveShipments(shipmentsWorkingCopy);
            affectedBaseNumbersForNotification.forEach(bn => {
                const finalShipmentState = shipmentsWorkingCopy[bn];
                if (finalShipmentState) {
                    const finalCount = calculateCurrentCountedPieces(finalShipmentState.scannedItems);
                    const expected = finalShipmentState.totalPiecesExpected;
                    if (expected !== null && finalCount === expected && !notifiedCompletions.has(bn)) {
                        notifyShipmentCompletion(finalShipmentState);
                    }
                }
            });
            let alertMessage = `Batch Verarbeitung:\n- Erfolgreich: ${successCount}\n- Fehler/√úbersprungen: ${errorCount}`;
            if (newBaseShipments.size > 0) {
                alertMessage += `\n- Neue Sendungen erstellt f√ºr: ${[...newBaseShipments].join(', ')}`;
            }
            if (errorMessages.length > 0) {
                alertMessage += `\n\nDetails:\n- ${errorMessages.join('\n- ')}`;
            }
            alert(alertMessage);
            renderTable();
            currentBatch = [];
            isBatchNotePromptRequired = true;
            currentBatchGlobalNote = null; 
            batchNoteToggleEl.checked = false; 
            updateBatchUI();
            displayCurrentShipmentDetails('');
            focusShipmentInput();
        }

        // --- Sonstige Aktionen (L√∂schen, PDF, Edit Modal) ---
        function deleteShipment(baseNumber) {
            const shipments = loadShipments();
            if (shipments[baseNumber]) {
                delete shipments[baseNumber];
                saveShipments(shipments);
                renderTable();
                const currentInputBase = processShipmentNumber(shipmentNumberInputEl.value).baseNumber;
                if (currentInputBase === baseNumber) { // Wenn gel√∂schte Sendung angezeigt wurde
                    displayCurrentShipmentDetails('');
                } else {
                    displayCurrentShipmentDetails(currentInputBase);
                }
                clearError();
            }
            focusShipmentInput();
        }
        // --- START: NEUE HILFSFUNKTION F√úR DUNKELALARM ---
        function calculateDunkelalarmCount(scannedItems) {
            if (!Array.isArray(scannedItems)) return 0;
            // Z√§hlt nur nicht-stornierte Scans mit dem Status "Dunkelalarm"
            return scannedItems.filter(item => 
                item.status === 'Dunkelalarm' && 
                !item.isCancelled
            ).length;
        }
        // --- ENDE: NEUE HILFSFUNKTION F√úR DUNKELALARM ---
        function requestCancelScanItem(baseNumber, itemTimestamp) {
            if (confirm(`Soll dieser Scan-Eintrag wirklich storniert werden?\nZeit: ${new Date(itemTimestamp).toLocaleString('de-DE')}`)) {
                cancelScanItem(baseNumber, itemTimestamp);
            }
        }
        function cancelScanItem(baseNumber, itemTimestamp) {
            const shipments = loadShipments();
            const shipment = shipments[baseNumber];
            if (!shipment || !shipment.scannedItems) return;

            const itemToCancel = shipment.scannedItems.find(item => item.timestamp === itemTimestamp && !item.isCancelled);

            if (itemToCancel) {
                const now = new Date();
                itemToCancel.isCancelled = true;
                itemToCancel.cancelledTimestamp = now.toISOString();

                // *** HIER IST DIE KORREKTUR ***
                // Wenn es sich um einen HU-Auftrag handelt UND der stornierte Status ein exklusiver Sicherheitsstatus war,
                // erstellen wir einen neuen "Anstehend"-Platzhalter, um die HU wieder scannbar zu machen.
                if (shipment.isHuListOrder && EXCLUSIVE_SECURITY_STATUSES.includes(itemToCancel.status)) {
                    const newPlaceholderItem = {
                        rawInput: itemToCancel.rawInput, // Die gleiche HU-Nummer
                        status: 'Anstehend',
                        timestamp: now.toISOString(), // Neuer Zeitstempel f√ºr den Platzhalter
                        isCombination: false,
                        notes: [],
                        isCancelled: false,
                        cancelledTimestamp: null
                    };
                    shipment.scannedItems.push(newPlaceholderItem);
                }
                // *** ENDE DER KORREKTUR ***

                shipment.lastModified = now.toISOString();
                saveShipments(shipments);
                displayCurrentShipmentDetails(baseNumber);
                renderTable();
                clearError();
            } else {
                displayError("Fehler: Eintrag zum Stornieren nicht gefunden oder bereits storniert.");
            }
            focusShipmentInput();
        }
        
        function openEditModal(baseNumber) {
            removeActiveInlineNoteEditor();
            const shipments = loadShipments();
            const shipment = shipments[baseNumber];
            if (!shipment) { displayError(`Sendung ${escapeHtml(baseNumber)} nicht gefunden.`); return; }
            
            editShipmentBaseNumberInputEl.value = baseNumber;
            editShipmentNumberDisplayEl.value = baseNumber;
            editTotalPiecesExpectedInputEl.value = shipment.totalPiecesExpected ?? '';
            editGoodsReceiptCountInputEl.value = ''; 
            
            editModalEl.classList.add('visible');
            document.body.classList.add('modal-open');
            // NEU: Diese Zeile auskommentieren, um die Tastatur zu unterdr√ºcken.
            // editTotalPiecesExpectedInputEl.focus();
        }
        function closeEditModal() {
            editModalEl.classList.remove('visible');
            document.body.classList.remove('modal-open'); // NEU
            focusShipmentInput();
        }

        function saveShipmentChangesFromModal() {
            const baseNumber = editShipmentBaseNumberInputEl.value;
            const newTotalExpectedStr = editTotalPiecesExpectedInputEl.value.trim();
            const manualReceiptCountStr = editGoodsReceiptCountInputEl.value.trim();

            let newTotalExpected = null;
            if (!baseNumber) { displayError("Fehler: Keine Sendungsnummer zum Speichern."); return; }

            if (newTotalExpectedStr !== '') {
                const parsedNum = parseInt(newTotalExpectedStr, 10);
                if (!isNaN(parsedNum) && parsedNum > 0) {
                    newTotalExpected = parsedNum;
                } else {
                    alert("Ung√ºltige Eingabe f√ºr St√ºckzahl. Bitte eine positive Zahl eingeben oder Feld leer lassen.");
                    editTotalPiecesExpectedInputEl.focus(); return;
                }
            }
            
            const shipments = loadShipments();
            if (!shipments[baseNumber]) { displayError(`Fehler: Sendung ${escapeHtml(baseNumber)} nicht mehr gefunden.`); closeEditModal(); return; }
            
            shipments[baseNumber].totalPiecesExpected = newTotalExpected;

            if (manualReceiptCountStr !== '') {
                const manualReceiptCount = parseInt(manualReceiptCountStr, 10);
                if (isNaN(manualReceiptCount) || manualReceiptCount < 0) {
                    alert("Ung√ºltige Eingabe f√ºr Anzahl Wareneingang. Bitte eine positive Zahl eingeben.");
                    editGoodsReceiptCountInputEl.focus();
                    return;
                }
                
                shipments[baseNumber].scannedItems = shipments[baseNumber].scannedItems.filter(item => item.status !== 'Wareneingang');

                for (let i = 0; i < manualReceiptCount; i++) {
                    shipments[baseNumber].scannedItems.push({
                        // --- √ÑNDERUNG HIER ---
                        rawInput: baseNumber, // Anstatt 'Manuell erfasst' wird die Sendungsnummer verwendet
                        // --- ENDE DER √ÑNDERUNG ---
                        status: 'Wareneingang',
                        timestamp: new Date().toISOString(),
                        isCombination: false,
                        notes: [],
                        isCancelled: false,
                        cancelledTimestamp: null
                    });
                }
            }

            shipments[baseNumber].lastModified = new Date().toISOString();
            saveShipments(shipments);
            
            closeEditModal();
            renderTable();
            displayCurrentShipmentDetails(baseNumber);
            displayError(`√Ñnderungen f√ºr ${escapeHtml(baseNumber)} gespeichert.`, 'green', 2500);

            const finalCount = calculateCurrentCountedPieces(shipments[baseNumber].scannedItems);
            if (newTotalExpected !== null && finalCount === newTotalExpected && !notifiedCompletions.has(baseNumber)) {
                notifyShipmentCompletion(shipments[baseNumber]);
            }
        }
    function generatePdf(baseNumber) {
        const shipments = loadShipments();
        const shipment = shipments[baseNumber];
        if (!shipment || !shipment.scannedItems || shipment.scannedItems.length === 0) {
            displayError(`Keine Scans f√ºr ${escapeHtml(baseNumber)} f√ºr PDF.`); return;
        }
        try {
            const doc = new jsPDF();
            const expected = shipment.totalPiecesExpected;
            const securityScansCount = calculateCurrentCountedPieces(shipment.scannedItems);
            const receiptScansCount = calculateGoodsReceiptCount(shipment.scannedItems);

            doc.setFontSize(18); doc.text(`Sicherheitsprotokoll: ${baseNumber}`, 14, 20);
            doc.setFontSize(10);
            doc.text(`Mitarbeiter: ${MITARBEITER_NAME}`, 14, 30);
            doc.text(`RegB Nummer: ${RAC_NUMMER}`, 14, 35);
            doc.text(`Gesamtst√ºcke erwartet: ${expected !== null ? expected : 'N/A'}`, 14, 40);
            
            // --- NEUE ZEILEN F√úR PDF-HEADER ---
            doc.text(`Wareneingang erfasst: ${receiptScansCount} von ${expected !== null ? expected : 'N/A'} Stk.`, 14, 45);
            doc.text(`Sicherheitskontrolle: ${securityScansCount} von ${expected !== null ? expected : 'N/A'} Stk.`, 14, 50);
            
            doc.text(`Letzte √Ñnderung: ${new Date(shipment.lastModified).toLocaleString('de-DE')}`, 14, 55);
            doc.text(`Generiert am: ${new Date().toLocaleString('de-DE')}`, 14, 60);

            let startY = 70; // Etwas mehr Platz nach oben
            if (doc.autoTable) {
                const tableData = shipment.scannedItems
                    .filter(item => item.status !== 'Anstehend')
                    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
                    .map(item => {
                        let statusText = item.status;
                        if (item.isCombination) statusText += ' (Kombi)';
                        if (item.isCancelled) statusText += ' (Storniert)';
                        let noteText = '';
                        if (item.notes && item.notes.length > 0) {
                            noteText = `\nNotizen: ${item.notes.join('; ')}`;
                        }
                        return [
                            new Date(item.timestamp).toLocaleString('de-DE'),
                            item.rawInput, RAC_NUMMER, MITARBEITER_NAME, statusText + noteText
                        ];
                    });
                doc.autoTable({
                    head: [['Zeitstempel', 'Gescannte Nummer', 'RegB Nummer', 'Mitarbeiter', 'Status/Notiz']],
                    body: tableData, startY: startY, theme: 'grid',
                    headStyles: { fillColor: [220, 220, 220], textColor: 0, fontStyle: 'bold' },
                    styles: { fontSize: 8, cellPadding: 1.5, overflow: 'linebreak' },
                    columnStyles: { 0:{cellWidth:28}, 1:{cellWidth:'auto'}, 2:{cellWidth:35}, 3:{cellWidth:30}, 4:{cellWidth:'auto'} },
                    didParseCell: function (data) {
                         const originalItem = shipment.scannedItems
                            .filter(item => item.status !== 'Anstehend')
                            .sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp))[data.row.index];
                        if (originalItem && originalItem.isCancelled) { data.cell.styles.textColor = [150,150,150]; }
                    }
                });
                startY = doc.autoTable.previous.finalY + 10;
            } else { alert("PDF AutoTable nicht verf√ºgbar."); return; }

// --- NEUER, INTELLIGENTER CODE-BLOCK ---
const validScans = shipment.scannedItems.filter(item => 
    !item.isCombination && 
    !item.isCancelled && 
    !NON_COUNTING_STATUSES.includes(item.status)
);

let summaryString = "Sicherheitsstatus: ";

if (validScans.length > 0) {
    const statusCounts = validScans.reduce((acc, item) => {
        acc[item.status] = (acc[item.status] || 0) + 1;
        return acc;
    }, {});

    const uniqueMethods = Object.keys(statusCounts);

    if (uniqueMethods.length === 1) {
        // Fall 1: Nur eine Methode wurde verwendet
        summaryString += "SPX by " + uniqueMethods[0];
    } else {
        // Fall 2: Mehrere Methoden wurden verwendet, mit Z√§hlung
        const summaryParts = uniqueMethods.sort().map(status => {
            return `${status} (${statusCounts[status]}x)`;
        });
        summaryString += "SPX by " + summaryParts.join(', ');
    }
} else {
    summaryString += "Keine z√§hlende Sicherungsmethode angewendet.";
}
// --- ENDE DES NEUEN BLOCKS ---
            
            doc.setFontSize(11); doc.setFont(undefined, 'bold');
            if (startY > 280) { doc.addPage(); startY = 20; }
            doc.text(summaryString, 14, startY);
            doc.output('dataurlnewwindow');
            clearError();
        } catch (error) { console.error("PDF Fehler:", error); displayError("Fehler beim Erstellen/√ñffnen des PDFs."); }
        focusShipmentInput();
    }        
        // --- Google Sheet & E-Mail Integration ---
        async function sendDataToSheet() {
            removeActiveInlineNoteEditor();
            if (!WEB_APP_URL || WEB_APP_URL.includes('YOUR_DEPLOYED_WEB_APP_URL_HERE')) {
                sheetStatusEl.textContent = 'Fehler: Web App URL fehlt.'; sheetStatusEl.style.color = 'red';
                alert("Fehler: Die Web App URL wurde nicht im Skript konfiguriert."); return;
            }
            sheetStatusEl.textContent = 'Sende Daten an Google Sheet...'; sheetStatusEl.style.color = '#f0ad4e';
            sendToSheetButtonEl.disabled = true; clearError();
            try {
                const shipmentsData = loadShipments();
                if (Object.keys(shipmentsData).length === 0) {
                    sheetStatusEl.textContent = 'Keine Daten zum Senden.'; sheetStatusEl.style.color = 'blue'; return;
                }
                const response = await fetch(WEB_APP_URL, {
                    method: 'POST', mode: 'cors', cache: 'no-cache',
                    headers: { 'Content-Type': 'text/plain;charset=utf-8' }, // text/plain f√ºr Gas POST
                    body: JSON.stringify({action: "saveAllData", payload: shipmentsData}) // Struktur f√ºr Gas
                });
                if (!response.ok) throw new Error(`Server Verbindung: ${response.status} ${response.statusText}`);
                const result = await response.json();
                if (result.status === 'success') {
                    sheetStatusEl.textContent = `Erfolg: ${result.message || 'Daten gesendet.'}`; sheetStatusEl.style.color = 'green';
                    setTimeout(closeSideMenu, 1500);
                } else {
                    throw new Error(`Apps Script Fehler: ${result.message || 'Unbekannt'}`);
                }
            } catch (error) {
                console.error("Fehler beim Senden an Google Sheet:", error);
                sheetStatusEl.textContent = `Fehler: ${error.message}`; sheetStatusEl.style.color = 'red';
                alert(`Fehler beim Senden:\n${error.message}`);
            } finally {
                sendToSheetButtonEl.disabled = false;
                setTimeout(() => { if (sheetStatusEl.textContent && !sheetStatusEl.textContent.startsWith('Erfolg')) sheetStatusEl.textContent = ''; }, 7000);
            }
        }

        async function notifyShipmentCompletion(shipmentObject) {
            const baseNumber = shipmentObject.hawb;
            if (!baseNumber) { console.error("Konnte HAWB f√ºr Benachrichtigung nicht ermitteln."); return; }
            if (!WEB_APP_URL || WEB_APP_URL.includes('YOUR_DEPLOYED_WEB_APP_URL_HERE')) {
                console.warn("Web App URL fehlt, keine Abschluss-Benachrichtigung."); return;
            }
            if (notifiedCompletions.has(baseNumber)) return; // Bereits benachrichtigt

            console.log(`Sende Abschluss-Benachrichtigung f√ºr ${baseNumber}...`);
            notifiedCompletions.add(baseNumber); // Als benachrichtigt markieren
            
            const notificationData = { action: 'shipmentComplete', shipmentData: shipmentObject };
            try {
                const response = await fetch(WEB_APP_URL, {
                    method: 'POST', mode: 'cors', cache: 'no-cache',
                    headers: { 'Content-Type': 'text/plain;charset=utf-8' },
                    body: JSON.stringify(notificationData)
                });
                if (!response.ok) throw new Error(`Server Fehler (Mail): ${response.status} ${response.statusText}`);
                const result = await response.json();
                if (result.status === 'success') {
                    console.log(`Abschluss-Benachrichtigung f√ºr ${baseNumber} erfolgreich gesendet.`);
                    displayError(`Sendung ${escapeHtml(baseNumber)} abgeschlossen! Benachrichtigung gesendet.`, 'blue', 4000);
                } else {
                    throw new Error(`Apps Script Fehler (Mail): ${result.message || 'Unbekannt'}`);
                }
            } catch (error) {
                console.error(`Fehler beim Senden der Abschluss-Benachrichtigung f√ºr ${baseNumber}:`, error);
                notifiedCompletions.delete(baseNumber); // Bei Fehler wieder freigeben f√ºr erneuten Versuch
                displayError(`Fehler beim Senden der Mail f√ºr ${escapeHtml(baseNumber)}.`);
            }
        }

        async function sendSummaryEmail() {
            removeActiveInlineNoteEditor();
            if (!WEB_APP_URL || WEB_APP_URL.includes('YOUR_DEPLOYED_WEB_APP_URL_HERE')) {
                 sheetStatusEl.textContent = 'Fehler: Web App URL fehlt.'; sheetStatusEl.style.color = 'red';
                 alert("Fehler: Web App URL fehlt."); return;
            }
            const shipmentsData = loadShipments();
            if (Object.keys(shipmentsData).length === 0) {
                sheetStatusEl.textContent = 'Keine Daten f√ºr Zusammenfassung.'; sheetStatusEl.style.color = 'blue';
                setTimeout(() => { if(sheetStatusEl.style.color === 'blue') sheetStatusEl.textContent = ''; }, 3000); return;
            }
            sheetStatusEl.textContent = 'Sende E-Mail-Zusammenfassung...'; sheetStatusEl.style.color = '#f0ad4e';
            sendSummaryEmailButtonEl.disabled = true; clearError();
            const payload = { action: 'sendSummaryEmail', allShipmentsData: shipmentsData, mitarbeiter: MITARBEITER_NAME };
            try {
                const response = await fetch(WEB_APP_URL, {
                    method: 'POST', mode: 'cors', cache: 'no-cache',
                    headers: { 'Content-Type': 'text/plain;charset=utf-8' }, body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`Server Verbindung: ${response.status} ${response.statusText}`);
                const result = await response.json();
                if (result.status === 'success') {
                    sheetStatusEl.textContent = `Erfolg: ${result.message || 'Zusammenfassung gesendet.'}`; sheetStatusEl.style.color = 'green';
                    setTimeout(closeSideMenu, 1500);
                } else {
                    throw new Error(`Apps Script Fehler: ${result.message || 'Unbekannt'}`);
                }
            } catch (error) {
                console.error("Fehler beim Senden der E-Mail:", error);
                sheetStatusEl.textContent = `Fehler: ${error.message}`; sheetStatusEl.style.color = 'red';
                alert(`Fehler beim Senden der Zusammenfassung:\n${error.message}`);
            } finally {
                sendSummaryEmailButtonEl.disabled = false;
                setTimeout(() => { if (sheetStatusEl.textContent && !sheetStatusEl.textContent.startsWith('Erfolg')) sheetStatusEl.textContent = ''; }, 7000);
            }
        }

            // --- START: Doppelklick-Logik f√ºr manuelle Eingabe im HU-Modal ---
            function enableManualInputOnDoubleClick(event) {
                const element = event.target;
                element.removeAttribute('readonly');
                element.setAttribute('inputmode', 'text');
                setTimeout(() => {
                    element.focus();
                    element.select();
                }, 50);
            }

            mainOrderNumberInputEl.addEventListener('dblclick', enableManualInputOnDoubleClick);
            huListTextareaEl.addEventListener('dblclick', enableManualInputOnDoubleClick);
            // --- ENDE: Doppelklick-Logik ---
        // --- Seitenmen√º ---
        function openSideMenu() { removeActiveInlineNoteEditor(); sideMenuEl.classList.add('open'); menuOverlayEl.classList.add('visible'); }
        function closeSideMenu() { sideMenuEl.classList.remove('open'); menuOverlayEl.classList.remove('visible'); sheetStatusEl.textContent = ''; focusShipmentInput(); }
            // --- START: Doppelklick-Logik f√ºr manuelle Eingabe im HU-Modal ---
            function enableManualInput(event) {
                const element = event.target;
                element.removeAttribute('readonly');
                element.setAttribute('inputmode', 'text'); // Tastatur anfordern
                // Kleiner Timeout, damit der Browser die √Ñnderung verarbeiten kann, bevor der Fokus gesetzt wird
                setTimeout(() => {
                    element.focus();
                    element.select(); // Text markieren f√ºr einfaches √úberschreiben
                }, 50);
            }

            mainOrderNumberInputEl.addEventListener('dblclick', enableManualInput);
            huListTextareaEl.addEventListener('dblclick', enableManualInput);

            importHuListButtonEl.addEventListener('click', () => {
                sideMenuEl.classList.remove('open');
                menuOverlayEl.classList.remove('visible');

                // Inputmode f√ºr Scanner zur√ºcksetzen
                mainOrderNumberInputEl.inputMode = 'none';
                huListTextareaEl.inputMode = 'none';

                mainOrderNumberInputEl.value = '';
                huListTextareaEl.value = '';
                importHuModalEl.classList.add('visible');
                document.body.classList.add('modal-open');
                // NEU: Diese Zeile auskommentieren, um das automatische √ñffnen der Tastatur zu verhindern.
                // mainOrderNumberInputEl.focus(); 
            });










        // --- Event Listener Setup ---
        function setupEventListeners() {
            mainActionButtonEl.addEventListener('click', () => {
                clearError();
                removeActiveInlineNoteEditor();
                if (isBatchModeActive) {
                    addToBatch();
                } else {
                    if (newTotalSectionEl.classList.contains('visible')) return; // Warten auf Total-Eingabe
                    const rawInput = shipmentNumberInputEl.value;
                    const status = securityStatusSelectEl.value;
                    const isCombination = comboCheckboxEl.checked;
                    const result = processAndSaveSingleScan(rawInput, status, isCombination);
                    if (!result.waitingForTotal) {
                        if (result.success) {
                            renderTable();
                            displayCurrentShipmentDetails(processShipmentNumber(rawInput).baseNumber);
                            shipmentNumberInputEl.value = '';
                            updateClearButtonVisibility(shipmentNumberInputEl, clearInputButtonEl);
                            displayError(result.message, 'green', 2000);
                        } else {
                            displayError(result.message);
                        }
                        focusShipmentInput();
                    } else { // Warten auf Gesamtst√ºckzahl
                        displayError(result.message, 'orange');
                        // Fokus ist auf newTotalInputEl
                    }
                }
            });

            shipmentNumberInputEl.addEventListener('input', () => {
                const currentValue = shipmentNumberInputEl.value.trim();

          
                
                    
                        
                            
                                
if (currentValue.startsWith('FRT_MULTI_V1')) {
    if (!confirm("Ein Multi-Auftrags-QR-Code wurde erkannt.\n\nM√∂chtest du alle darin enthaltenen Auftr√§ge jetzt importieren?")) {
        shipmentNumberInput.value = ''; return;
    }
    const parts = currentValue.split(';;;').slice(1);
    const shipments = loadShipments();
    const now = new Date().toISOString();
    let addedCount = 0, duplicateCount = 0, processedOrders = [];

    parts.forEach(orderData => {
        const [metaAndOrder, huData] = orderData.split('|||');
        if (!metaAndOrder || !huData) return;

        const metaParts = metaAndOrder.split('|');
        const orderNumber = metaParts[0];
        const hasFullMeta = metaParts.length >= 4;
        
        processedOrders.push(orderNumber);
        const hus = huData.split(' ').filter(Boolean);

        if (!shipments[orderNumber]) {
            const newShipment = {
                hawb: orderNumber, lastModified: now, totalPiecesExpected: hus.length,
                scannedItems: [], mitarbeiter: MITARBEITER_NAME, isHuListOrder: true,
            };
            if (hasFullMeta) {
                newShipment.freightForwarder = metaParts[1];
                newShipment.destinationCountry = metaParts[2];
                newShipment.plsoNumber = metaParts[3];
            }
            shipments[orderNumber] = newShipment;
            hus.forEach((hu, index) => {
                newShipment.scannedItems.push({ rawInput: hu, status: 'Anstehend', timestamp: now, isCombination: false, notes: [], isCancelled: false, cancelledTimestamp: null, position: index + 1 });
                addedCount++;
            });
        } else {
            // Logik zum Hinzuf√ºgen zu bestehenden Auftr√§gen bleibt gleich
        }
    });
    saveShipments(shipments);
    alert(`Multi-Import abgeschlossen:\n- Verarbeitete Auftr√§ge: ${processedOrders.length}\n- Neue HUs hinzugef√ºgt: ${addedCount}\n- Duplikate √ºbersprungen: ${duplicateCount}`);
    location.reload();
    return;
}
                // --- ENDE: NEUE LOGIK F√úR MULTI-QR-CODE ---
                // --- ENDE: NEUE LOGIK F√úR MULTI-QR-CODE ---

                updateClearButtonVisibility(shipmentNumberInputEl, clearInputButtonEl);

                if (isBatchModeActive) {
                    if (currentValue.length > 0) mainActionButtonEl.click();
                    return;
                }

                // --- START: KORRIGIERTE LOGIK F√úR DIE DETAILANZEIGE ---
                const shipments = loadShipments();
                const { baseNumber: processedDirectBase } = processShipmentNumber(currentValue);
                let baseNumberToShow = null;

                // Priorit√§t 1: Ist die Eingabe eine bekannte HU-Nummer?
                const parentHawbByHu = findShipmentByHuNumber(currentValue);
                if (parentHawbByHu) {
                    baseNumberToShow = parentHawbByHu;
                    displayError(`HU '${escapeHtml(currentValue)}' geh√∂rt zu Auftrag: ${escapeHtml(baseNumberToShow)}`, 'blue', 3500);
                } 
                // Priorit√§t 2: Ist die Eingabe eine bekannte HAWB?
                else if (shipments[processedDirectBase.toUpperCase()]) {
                    baseNumberToShow = processedDirectBase.toUpperCase();
                    clearError();
                } 
                // Priorit√§t 3: Ist die Eingabe eine Notiz?
                else if (currentValue.length > 3) {
                    const parentHawbByNote = findShipmentByNoteContent(currentValue);
                    if (parentHawbByNote) {
                        baseNumberToShow = parentHawbByNote;
                        displayError(`Notiz '${escapeHtml(currentValue)}' gefunden f√ºr HAWB: ${escapeHtml(baseNumberToShow)}`, 'blue', 3500);
                    }
                }

                // Detailansicht aktualisieren: Entweder mit der gefundenen HAWB oder dem, was getippt wurde (f√ºr neue Sendungen)
                displayCurrentShipmentDetails(baseNumberToShow || processedDirectBase);
                filterTable(baseNumberToShow || currentValue);
                // --- ENDE: KORRIGIERTE LOGIK F√úR DIE DETAILANZEIGE ---
            });

            clearInputButtonEl.addEventListener('click', () => {
                shipmentNumberInputEl.value = '';
                updateClearButtonVisibility(shipmentNumberInputEl, clearInputButtonEl);
                clearError();
                displayCurrentShipmentDetails('');
                filterTable('');
                resetSingleScanNoteInputState();
                updateNoteAndComboVisibility();
                focusShipmentInput();
            });
            shipmentNumberInputEl.addEventListener('blur', () => {
                if (isBatchModeActive) {
                    setTimeout(focusShipmentInput, 10);
                }
            });
            securityStatusSelectEl.addEventListener('change', () => {
                updateNoteAndComboVisibility();
                focusShipmentInput();
            });
            comboCheckboxEl.addEventListener('change', focusShipmentInput);


            noteToggleButtonEl.addEventListener('click', () => {
                const isVisible = noteInputContainerEl.style.display === 'block';
                noteInputContainerEl.style.display = isVisible ? 'none' : 'block';
                if (!isVisible) noteInputEl.focus(); else focusShipmentInput();
            });
        
            noteInputEl.addEventListener('input', () => {
                const noteValue = noteInputEl.value.trim();
                noteToggleButtonEl.classList.toggle('note-active', noteValue !== '');
                updateClearButtonVisibility(noteInputEl, clearNoteButtonEl);

                const suggestions = document.getElementById('noteSuggestions').options;
                let isSuggestionSelected = false;
                for (let i = 0; i < suggestions.length; i++) {
                    if (suggestions[i].value === noteInputEl.value) {
                        isSuggestionSelected = true;
                        break;
                    }
                }

                if (isSuggestionSelected) {
                    focusShipmentInput();
                }
            });
            clearNoteButtonEl.addEventListener('click', () => {
                resetSingleScanNoteInputState();
                focusShipmentInput();
            });

            currentDetailsDivEl.addEventListener('click', (event) => {
                const target = event.target;
                event.preventDefault();

                if (target.classList.contains('editable-note') || target.classList.contains('add-note-link')) {
                    showInlineNoteEditor(target);
                } else if (target.classList.contains('inline-note-save-btn')) {
                    const editorDiv = target.closest('.inline-note-editor');
                    if (editorDiv) {
                        const inputField = editorDiv.querySelector('.inline-note-input');
                        const noteIndex = target.dataset.noteIndex;
                        saveOrUpdateNote(target.dataset.basenumber, target.dataset.timestamp, noteIndex, inputField.value);
                    }
                } else if (target.classList.contains('inline-note-cancel-btn')) {
                    removeActiveInlineNoteEditor();
                    focusShipmentInput();
                } else if (target.classList.contains('cancel-button')) {
                    requestCancelScanItem(target.dataset.basenumber, target.dataset.timestamp);
                } else if (target.classList.contains('delete-note-btn')) {
                    requestDeleteNote(target.dataset.basenumber, target.dataset.timestamp, target.dataset.noteIndex);
                }
            });

            tableBodyEl.addEventListener('click', (event) => {
                const target = event.target;
                const baseNumber = target.dataset.basenumber;
                if (!baseNumber) return;

                if (target.classList.contains('edit-btn') && !isBatchModeActive) {
                    openEditModal(baseNumber);
                } else if (target.classList.contains('pdf-btn')) {
                    generatePdf(baseNumber);
                } else if (target.classList.contains('main-delete-btn')) {
                    if (confirm(`Sendung ${escapeHtml(baseNumber)} wirklich l√∂schen?`)) {
                        deleteShipment(baseNumber);
                    }
                }
            });
            
            // Modals
            saveEditButtonEl.addEventListener('click', saveShipmentChangesFromModal);
            cancelEditButtonEl.addEventListener('click', closeEditModal);
            editModalEl.addEventListener('click', (e) => { if (e.target === editModalEl) closeEditModal(); });

            confirmNewTotalBtnEl.addEventListener('click', () => completeNewShipmentSave(newTotalInputEl.value));
            skipNewTotalBtnEl.addEventListener('click', () => completeNewShipmentSave(null));
            newTotalInputEl.addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); confirmNewTotalBtnEl.click(); }});

            // Batch Modus
            batchModeToggleEl.addEventListener('change', (e) => toggleBatchMode(e.target.checked));
            saveBatchButtonEl.addEventListener('click', saveBatch);
            clearBatchButtonEl.addEventListener('click', () => {
                if (currentBatch.length > 0 && confirm("Aktuellen Batch wirklich leeren?")) {
                    currentBatch = [];
                    isBatchNotePromptRequired = true;
                    currentBatchGlobalNote = null; // <-- WICHTIGE √ÑNDERUNG: Notiz zur√ºcksetzen
                    batchNoteToggleEl.checked = false;
                    updateBatchUI(); clearError(); displayCurrentShipmentDetails('');
                } else if (currentBatch.length === 0) {
                    displayError("Batch ist bereits leer.");
                }
                focusShipmentInput();
            });            
            // Listener f√ºr den Notiz-Schalter, um das Modal auch mitten im Batch zu √∂ffnen
            batchNoteToggleEl.addEventListener('change', () => {
                if (batchNoteToggleEl.checked && isBatchModeActive) {
                    batchNoteInputEl.value = currentBatchGlobalNote || '';
                    batchNoteModalEl.classList.add('visible');
                    document.body.classList.add('modal-open');
                    // NEU: Diese Zeile auskommentieren.
                    // batchNoteInputEl.focus();
                }
            });

            confirmBatchNoteButtonEl.addEventListener('click', confirmAndAddFirstBatchItemWithNote); // schlie√üt Modal intern
            skipBatchNoteButtonEl.addEventListener('click', skipNoteAndAddFirstBatchItem);       // schlie√üt Modal intern
            batchNoteModalEl.addEventListener('click', (e) => { if (e.target === batchNoteModalEl) skipNoteAndAddFirstBatchItem(); });

            // Seitenmen√º
            menuToggleBtnEl.addEventListener('click', (e) => { e.stopPropagation(); sideMenuEl.classList.contains('open') ? closeSideMenu() : openSideMenu(); });
            menuOverlayEl.addEventListener('click', closeSideMenu);
            sendToSheetButtonEl.addEventListener('click', sendDataToSheet);
            resetDataButtonEl.addEventListener('click', () => {
                removeActiveInlineNoteEditor();
                if (confirm("WARNUNG!\n\nM√∂chtest du wirklich ALLE erfassten Sendungsdaten unwiderruflich l√∂schen?")) {
                    // Die Hauptaktion bleibt: Lokalen Speicher leeren
                    localStorage.removeItem(LOCAL_STORAGE_KEY);
                    
                    // NEU: Seite neu laden, um den Reset abzuschlie√üen.
                    // Die UI-Updates danach sind nicht mehr n√∂tig, da die Seite von Grund auf neu l√§dt.
                    location.reload(); 
                } else {
                    sheetStatusEl.textContent = 'Zur√ºcksetzen abgebrochen.';
                    sheetStatusEl.style.color = 'blue';
                    setTimeout(() => { if (sheetStatusEl.textContent.includes('abgebrochen')) sheetStatusEl.textContent = ''; }, 3000);
                }
            });
            sendSummaryEmailButtonEl.addEventListener('click', sendSummaryEmail);

            // Double-Click auf Input f√ºr manuelle Eingabe (optional)
            shipmentNumberInputEl.addEventListener('dblclick', () => {
                 if (!isBatchModeActive && !editModalEl.classList.contains('visible') && !batchNoteModalEl.classList.contains('visible')) {
                    shipmentNumberInputEl.inputMode = 'text';
                    setTimeout(() => shipmentNumberInputEl.focus(), 0);
                 }
            });

            importHuListButtonEl.addEventListener('click', () => {
                // 1. Zwingt die Tastatur zum Schlie√üen, indem der Fokus vom aktuellen Element genommen wird.
                if (document.activeElement && typeof document.activeElement.blur === 'function') {
                    document.activeElement.blur();
                }

                sideMenuEl.classList.remove('open');
                menuOverlayEl.classList.remove('visible');
                
                // 2. Setzt Felder in den "Scanner-Modus".
                mainOrderNumberInputEl.inputMode = 'none';
                huListTextareaEl.inputMode = 'none';
                
                // 3. NEU: Macht die Felder explizit un-fokussierbar, um Android daran zu hindern, die Tastatur zu √∂ffnen.
                mainOrderNumberInputEl.setAttribute('tabindex', '-1');
                huListTextareaEl.setAttribute('tabindex', '-1');

                mainOrderNumberInputEl.value = '';
                huListTextareaEl.value = '';
                importHuModalEl.classList.add('visible');
                document.body.classList.add('modal-open');
            });

            cancelHuImportButtonEl.addEventListener('click', () => {
                importHuModalEl.classList.remove('visible');
		document.body.classList.remove('modal-open'); 
                focusShipmentInput();
            });


            // --- Doppelklick-Logik f√ºr manuelle Eingabe im HU-Modal ---
            mainOrderNumberInputEl.addEventListener('dblclick', () => {
                mainOrderNumberInputEl.inputMode = 'text';
                mainOrderNumberInputEl.focus();
            });

            huListTextareaEl.addEventListener('dblclick', () => {
                huListTextareaEl.inputMode = 'text';
                huListTextareaEl.focus();
            });

            // --- HIER IST DER NEUE BLOCK ---
            // Automatischer Zeilenumbruch beim Scannen in der Textarea
            huListTextareaEl.addEventListener('input', () => {
                if (huListTextareaEl.inputMode === 'none') {
                    huListTextareaEl.value += '\n';
                    huListTextareaEl.scrollTop = huListTextareaEl.scrollHeight;
                }
            });
            // --- ENDE DES NEUEN BLOCKS ---
            // ===== START: NEUE EVENT LISTENER F√úR HU-ZUSAMMENFASSUNG =====
            showOpenHusButtonEl.addEventListener('click', (e) => {
                e.preventDefault();
                showOpenHusSummary();
            });
            
            closeOpenHusModalButtonEl.addEventListener('click', () => {
                openHusModalEl.classList.remove('visible');
                document.body.classList.remove('modal-open'); // NEU
                focusShipmentInput();
            });
            
            openHusModalEl.addEventListener('click', (e) => {
                if (e.target === openHusModalEl) {
                    openHusModalEl.classList.remove('visible');
                    document.body.classList.remove('modal-open'); // NEU
                    focusShipmentInput();
                }
            });
            
// --- START DER √ÑNDERUNG: Die Event-Listener f√ºr die Modal-Tabs werden aktualisiert ---
            // ===== START: EVENT LISTENER F√úR HU-MODAL-TABS =====
            showOpenSecurityHusBtnEl.addEventListener('click', () => {
                showOpenSecurityHusBtnEl.classList.add('active');
                showMissingReceiptHusBtnEl.classList.remove('active');
                showDunkelalarmHusBtnEl.classList.remove('active');

                openHusListContainerEl.style.display = 'block';
                missingReceiptHusListContainerEl.style.display = 'none';
                dunkelalarmHusListContainerEl.style.display = 'none';
            });

            showMissingReceiptHusBtnEl.addEventListener('click', () => {
                showMissingReceiptHusBtnEl.classList.add('active');
                showOpenSecurityHusBtnEl.classList.remove('active');
                showDunkelalarmHusBtnEl.classList.remove('active');

                missingReceiptHusListContainerEl.style.display = 'block';
                openHusListContainerEl.style.display = 'none';
                dunkelalarmHusListContainerEl.style.display = 'none';
            });

            // Neuer Listener f√ºr den Dunkelalarm-Tab
            showDunkelalarmHusBtnEl.addEventListener('click', () => {
                showDunkelalarmHusBtnEl.classList.add('active');
                showOpenSecurityHusBtnEl.classList.remove('active');
                showMissingReceiptHusBtnEl.classList.remove('active');

                dunkelalarmHusListContainerEl.style.display = 'block';
                openHusListContainerEl.style.display = 'none';
                missingReceiptHusListContainerEl.style.display = 'none';
            });
            // ===== ENDE: EVENT LISTENER F√úR HU-MODAL-TABS =====
// --- ENDE DER √ÑNDERUNG ---
        } // Ende der setupEventListeners Funktion








                    // Wiederverwendbare Funktion zum Speichern der HU-Liste
            function saveAndProcessHuListData() {
                const mainOrderNumber = mainOrderNumberInputEl.value.trim().toUpperCase();
                const huListText = huListTextareaEl.value.trim();

                if (!mainOrderNumber || !huListText) {
                    alert("Bitte Auftragsnummer und mindestens eine HU-Nummer eingeben.");
                    return { success: false };
                }
                const hus = huListText.split(/[\s\n\r]+/).map(hu => hu.trim().toUpperCase()).filter(hu => hu.length > 0);
                if (hus.length === 0) {
                    alert("Keine g√ºltigen HU-Nummern in der Liste gefunden.");
                    return { success: false };
                }

                const shipments = loadShipments();
                const now = new Date().toISOString();
                let addedCount = 0;
                let duplicateCount = 0;

                if (!shipments[mainOrderNumber]) {
                    shipments[mainOrderNumber] = {
                        hawb: mainOrderNumber, lastModified: now, totalPiecesExpected: hus.length,
                        scannedItems: [], mitarbeiter: MITARBEITER_NAME, isHuListOrder: true
                    };
                    hus.forEach(hu => {
                        shipments[mainOrderNumber].scannedItems.push({ rawInput: hu, status: 'Anstehend', timestamp: now, isCombination: false, notes: [], isCancelled: false, cancelledTimestamp: null });
                        addedCount++;
                    });
                } else {
                    if (!shipments[mainOrderNumber].isHuListOrder) {
                        alert(`FEHLER: ${mainOrderNumber} ist eine normale Sendung. Sie kann nicht mit einer HU-Liste erweitert werden.`);
                        return { success: false };
                    }
                    hus.forEach(hu => {
                        if (!shipments[mainOrderNumber].scannedItems.find(item => item.rawInput.toUpperCase() === hu)) {
                            shipments[mainOrderNumber].scannedItems.push({ rawInput: hu, status: 'Anstehend', timestamp: now, isCombination: false, notes: [], isCancelled: false, cancelledTimestamp: null });
                            addedCount++;
                        } else { duplicateCount++; }
                    });
                    if (addedCount > 0) {
                        shipments[mainOrderNumber].lastModified = now;
                        shipments[mainOrderNumber].totalPiecesExpected += addedCount;
                    }
                }

                saveShipments(shipments);
                renderTable();
                
                let message = '';
                let messageType = 'green';
                if (addedCount > 0 && duplicateCount === 0) {
                    message = `${addedCount} neue HU(s) zum Auftrag ${mainOrderNumber} hinzugef√ºgt.`;
                } else if (addedCount > 0 && duplicateCount > 0) {
                    message = `${addedCount} neue HU(s) hinzugef√ºgt, ${duplicateCount} Duplikate √ºbersprungen.`;
                    messageType = 'orange';
                } else if (addedCount === 0 && duplicateCount > 0) {
                    alert(`Import f√ºr ${mainOrderNumber}:\n\nKeine neuen HUs gefunden. Alle ${duplicateCount} eingegebenen HUs sind bereits im Auftrag vorhanden.`);
                }
                
                return { success: true, message: message, messageType: messageType, baseNumber: mainOrderNumber };
            }

            // Listener f√ºr den "Importieren & Speichern"-Button (schlie√üt das Modal)
            saveHuListButtonEl.addEventListener('click', () => {
                const result = saveAndProcessHuListData();
                if (result.success) {
                    displayCurrentShipmentDetails(result.baseNumber);
                    importHuModalEl.classList.remove('visible');
                    document.body.classList.remove('modal-open'); // <-- DIESE ZEILE IST NEU
                    if (result.message) {
                        displayError(result.message, result.messageType, 5000);
                    }
                    focusShipmentInput();
                }
            });

            // Listener f√ºr den neuen "+"-Button (speichert und leert die Felder)
            addAndContinueHuButtonEl.addEventListener('click', () => {
                const result = saveAndProcessHuListData();
                if (result.success) {
                    displayCurrentShipmentDetails(result.baseNumber);
                    if (result.message) {
                       displayError(result.message, result.messageType, 5000);
                    }
                    // Felder f√ºr die n√§chste Eingabe leeren
                    mainOrderNumberInputEl.value = '';
                    huListTextareaEl.value = '';
                    mainOrderNumberInputEl.focus();
                }
            });

        // --- Initialisierung ---
        function initializeApp() {
            renderTable();
            isBatchModeActive = batchModeToggleEl.checked; // Zustand vom Toggle √ºbernehmen
            sessionFirstSuffixScans = {}; // Reset bei jedem Laden
            notifiedCompletions = new Set(); // Reset bei jedem Laden
            
            resetSingleScanNoteInputState();
            toggleBatchMode(isBatchModeActive); // Initial Batch Mode anwenden (setzt auch Flags)
            // displayCurrentShipmentDetails(''); // Start mit leerem Details-Bereich
            updateClearButtonVisibility(shipmentNumberInputEl, clearInputButtonEl);
            updateClearButtonVisibility(noteInputEl, clearNoteButtonEl);
            updateCurrentBatchNoteDisplay(); // Initial Batch Notiz (leer)

            setupEventListeners();
            focusShipmentInput();
            console.log(`Fracht Tracker ${document.title.split('(')[1].split(')')[0]} initialized.`);
        }

        initializeApp();
    });

// Screen Orientation Lock (optional, mit geringer Erfolgschance ohne User Interaktion)
/*
function attemptLockOrientation() {
  if (screen.orientation && typeof screen.orientation.lock === 'function') {
    screen.orientation.lock(screen.orientation.type)
      .then(() => console.log('Bildschirmausrichtung gesperrt: ' + screen.orientation.type))
      .catch((error) => console.error('Sperren der Bildschirmausrichtung fehlgeschlagen:', error));
  } else { console.warn('Screen Orientation Lock API nicht unterst√ºtzt.'); }
}
// window.addEventListener('load', attemptLockOrientation);
*/
</script>
<audio id="errorSound" src="https://cdn.pixabay.com/download/audio/2022/12/13/audio_34d1e8985e.mp3?filename=error-call-to-attention-129258.mp3" preload="auto"></audio>

</body>
</html>


